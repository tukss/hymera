//========================================================================================
// (C) (or copyright) 2025. Triad National Security, LLC. All rights reserved.
//
// This program was produced under U.S. Government contract 89233218CNA000001 for Los
// Alamos National Laboratory (LANL), which is operated by Triad National Security, LLC
// for the U.S. Department of Energy/National Nuclear Security Administration. All rights
// in the program are reserved by Triad National Security, LLC, and the U.S. Department
// of Energy/National Nuclear Security Administration. The Government is granted for
// itself and others acting on its behalf a nonexclusive, paid-up, irrevocable worldwide
// license in this material to reproduce, prepare derivative works, distribute copies to
// the public, perform publicly and display publicly, and to permit others to do so.
//========================================================================================

#include "mfd_config.h"
#include "ts_functions.h"
#include "monitor_functions.h"
#include "geometry.h"
#include "mass_matrix_coefficients.h"
#include "mimetic_operators.h"
#include "kinetic/c_wrapper.h"

PetscErrorCode FormIJacobian_BImplicit(TS ts, PetscReal t, Vec X, Vec Xdot, PetscReal a, Mat J, Mat Jpre, void * ptr) {
  return (0);
}

PetscErrorCode FormIFunction_purediffusionVV(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_purediffusionVV",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = V; on all vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) = V ; on plasma vertices
           f1(V,EP,tau,B,ni) = V ; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];


        arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
        arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
        arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
        arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
        arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
        arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
        arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
        arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
        arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
        arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
        arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
        arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
        arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
        arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
        arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
        arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
        arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
        arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
        arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
        arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
        arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
        arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
        arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }


  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_purediffusion(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_purediffusion",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = V; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) = V ; on plasma vertices
           f1(V,EP,tau,B,ni) = V ; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]];

          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]];

          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] ;
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_Inertia_V(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Inertia_V",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  /* Compute the projection vectors */
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V))) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V))) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = (V . P_{e->v}(prim_mim_grad(V))) . P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V))) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V))) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = (V . P_{e->v}(prim_mim_grad(V))) . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + 1.0 * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) ;
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[0]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + 1.0 * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[2]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrBv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[1]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[2]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]);
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * (arrBv[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[0]] + arrBv[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] + arrBv[ez][ephi][er][ivVrmphimzm[2]] * arrX[ez][ephi][er][ivVrmphimzm[2]]) ;
          }
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_Inertia_V_ni(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Inertia_V_ni",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V))) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V))) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V))) . e_phi ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V))) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V))) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V))) . e_phi ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) ;
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[0]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[2]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[1]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[0]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) ;
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = arrBv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[1]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[2]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]);
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[1]] ;
            //arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * (arrBv[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[0]] + arrBv[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] + arrBv[ez][ephi][er][ivVrmphimzm[2]] * arrX[ez][ephi][er][ivVrmphimzm[2]]) ;
          }
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_Inertia_viscosity(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Inertia_viscosity",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V)) + Re^{-1} (\nabla^2 V)) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V)) + Re^{-1} (\nabla^2 V)) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V)) + Re^{-1} (\nabla^2 V)) . e_phi ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V)) + Re^{-1}(\nabla^2 V)) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V)) + Re^{-1}(\nabla^2 V)) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V)) + Re^{-1}(\nabla^2 V)) . e_phi ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[0]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[2]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[1]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[0]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[1]] ;
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = arrBv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[1]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[2]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]);
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[1]] ;
            //arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * (arrBv[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[0]] + arrBv[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] + arrBv[ez][ephi][er][ivVrmphimzm[2]] * arrX[ez][ephi][er][ivVrmphimzm[2]]) ;
          }
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_Vperp_viscosity(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Vperp_viscosity",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V. P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/(L0*V_A)) * derived_mimetic_div(derived_mimetic_curl(B)) = - derived_mimetic_div(primary_mimetic_grad(EP)) - derived_mimetic_div(derived_mimetic_curl_2(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - derived_mimetic_curl2(B) ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];

          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];

          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;

        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */


        /* f3(V,EP,tau,B,ni) = tau - derived_mimetic_curl2(B) + (eta/(V_A*B_0)) j_RE; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae2(er, ephi, ez, BACK_LEFT, user)) + (user->jrephi[er + user->Nr * ez] + user->jrephi[er - 1 + user->Nr * ez] + user->jrephi[er + user->Nr * (ez-1)] + user->jrephi[er - 1 + user->Nr * (ez-1)]) / 4.0 ;  //user->jreR
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae2(er, ephi, ez, BACK_DOWN, user)) + (user->jreR[er + user->Nr * ez] + user->jreR[er + user->Nr * (ez-1)]) / 2.0 ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user))
              + (user->jreZ[er - 1 + user->Nr * ez] + user->jreZ[er + user->Nr * ez]) / 2.0 ;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae2(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae2(er, ephi, ez, BACK_DOWN, user))
              + (user->jreR[er + user->Nr * ez] + user->jreR[er + user->Nr * (ez-1)]) / 2.0 ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user))
              + (user->jreZ[er - 1 + user->Nr * ez] + user->jreZ[er + user->Nr * ez]) / 2.0 ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae2(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_Vperp_viscosity_halo(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Vperp_viscosity_halo",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V. P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all inner vertices not inside the wall
     f2(V,EP,tau,B,ni) . e_r = [- derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(der_mim_curl_etaperp(B))] . e_r ; on all vertices inside the wall
     f2(V,EP,tau,B,ni) . e_z = [- derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(der_mim_curl_etaperp(B))] . e_z ; on all vertices inside the wall
     f2(V,EP,tau,B,ni) . e_phi = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl_etaphi-etaperp(B)); on all vertices inside the wall
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all inner edges not inside the wall
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * der_mim_curl_etaperp(B)_perp - (1/(L0*V_A)) * der_mim_curl_etaphi(B)_phi ; on all edges inside the wall
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];
          if(steps==0 && 0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];
          if(steps==0 && 0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[0]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[1]] ;
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = arrBv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[1]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[2]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]);
          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0 && 0){
            arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[1]] ;
            //arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * (arrBv[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[0]] + arrBv[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] + arrBv[ez][ephi][er][ivVrmphimzm[2]] * arrX[ez][ephi][er][ivVrmphimzm[2]]) ;
          }
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */


        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges not inside the wall
           f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * der_mim_curl_etaperp(B)_perp - (1/(L0*V_A)) * der_mim_curl_etaphi(B)_phi ; on all edges inside the wall */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betaephi2(er, ephi, ez, BACK_LEFT, user)) ;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betaeperp2(er, ephi, ez, BACK_DOWN, user)) ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user)) ;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betaeperp2(er, ephi, ez, BACK_DOWN, user)) ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user)) ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betaeperp2(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_Vperp_viscosity_halo_isolcell(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Vperp_viscosity_halo_isolcell",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V. P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)) = - derived_mimetic_div(primary_mimetic_grad(EP)) - derived_mimetic_div(derived_mimetic_curl2(B)); on all inner vertices not inside the wall
     f2(V,EP,tau,B,ni) . e_r = [- derived_mimetic_div(primary_mimetic_grad(EP)) - derived_mimetic_div(der_mim_curl2_etaperp(B))] . e_r ; on all vertices inside the wall
     f2(V,EP,tau,B,ni) . e_z = [- derived_mimetic_div(primary_mimetic_grad(EP)) - derived_mimetic_div(der_mim_curl2_etaperp(B))] . e_z ; on all vertices inside the wall
     f2(V,EP,tau,B,ni) . e_phi = - derived_mimetic_div(primary_mimetic_grad(EP)) - derived_mimetic_div(derived_mimetic_curl2_etaphi(B)); on all vertices inside the wall
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - derived_mimetic_curl2(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all inner edges not inside the wall
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * der_mim_curl_etaperp(B)_perp - (1/(L0*V_A)) * der_mim_curl_etaphi(B)_phi = tau - primary_mimetic_grad(EP) - der_mim_curl2_etaperp(B)_perp - der_mim_curl2_etaphi(B)_phi; on all edges inside the wall
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];
          if(steps==0 && 0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];
          if(steps==0 && 0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[0]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[1]] ;
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = arrBv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[1]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[2]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]);
          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0 && 0){
            arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[1]] ;
            //arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * (arrBv[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[0]] + arrBv[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] + arrBv[ez][ephi][er][ivVrmphimzm[2]] * arrX[ez][ephi][er][ivVrmphimzm[2]]) ;
          }
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */


        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - derived_mimetic_curl2(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges not inside the wall
           f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * der_mim_curl_etaperp(B)_perp - (1/(L0*V_A)) * der_mim_curl_etaphi(B)_phi = tau - der_mim_curl2_etaperp(B)_perp - der_mim_curl2_etaphi(B)_phi ; on all edges inside the wall */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betaephi_isolcell(er, ephi, ez, BACK_LEFT, user)) ;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betaeperp2(er, ephi, ez, BACK_DOWN, user)) ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user)) ;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betaeperp2(er, ephi, ez, BACK_DOWN, user)) ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user)) ;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betaeperp2(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_Inertia(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Inertia",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V)) + Re^{-1} (\nabla^2 V)) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - ni V . P_{e->v}(prim_mim_grad(V)) + Re^{-1} (\nabla^2 V)) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V. P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V)) + Re^{-1}(\nabla^2 V)) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - V . P_{e->v}(prim_mim_grad(V)) + Re^{-1}(\nabla^2 V)) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + 1.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[0]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + 1.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];
          if(steps==0||1){
            arrF[ez][ephi][er][ivVrmphimzm[2]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          }
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[0]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[1]] ;
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = arrBv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[1]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV2[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV2[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV2[ez][ephi][er][ivVrmphimzm[2]] + arrX[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]]) + arrBv[ez][ephi][er][ivVrmphimzm[2]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]);
          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
          if(steps==0 && 0){
            arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * arrX[ez][ephi][er][ivVrmphimzm[1]] ;
            //arrF[ez][ephi][er][ivVrmphimzm[1]] += user->dampV * (arrBv[ez][ephi][er][ivVrmphimzm[0]] * arrX[ez][ephi][er][ivVrmphimzm[0]] + arrBv[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] + arrBv[ez][ephi][er][ivVrmphimzm[2]] * arrX[ez][ephi][er][ivVrmphimzm[2]]) ;
          }
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction2(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction2",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal, curlBxB, curlBxBLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);

  /* Compute the projection vectors */
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = -(P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV * V) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = -(P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV * V) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau_0 ; on all edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl((1/(L0*V_A)) * derived_mimetic_curl(B) - R_ve(VxP_fv(B))); on inner plasma faces
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl((1/(L0*V_A)) * derived_mimetic_curl(B)); on other faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        //arrF has already zeros on boundary edges

        /* f3(V,EP,tau,B,ni) = (1/(L0*V_A)) * derived_mimetic_curl(B) = (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡  (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] =  ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] =  ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] =  ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] =  ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] =  ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] -= arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] -= arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] -= arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] -= arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] -= arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV V) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV V) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]];
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]);
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau_star) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrF[ez][ephi][er][ivErmzm] - rmzpedgelength * arrF[ez][ephi][er][ivErmzp] + rmphipedgelength * arrF[ez][ephi][er][ivErmphip] - rmphimedgelength * arrF[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrF[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrF[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrF[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrF[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrF[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrF[ez][ephi][er][ivErpzm] - rmzmedgelength * arrF[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrF[ez][ephi][er][ivErpzm] - rpzpedgelength * arrF[ez][ephi][er][ivErpzp] + rpphipedgelength * arrF[ez][ephi][er][ivErpphip] - rpphimedgelength * arrF[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrF[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrF[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrF[ez][ephi][er][ivErpphip] + rmphipedgelength * arrF[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrF[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrF[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrF[ez][ephi][er][ivErpzp] - rmzpedgelength * arrF[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    Vec tauF, tauX;
    VecGetSubVector( F, user -> istau, & tauF);
    VecGetSubVector( X, user -> istau, & tauX);
    VecAYPX(tauF,-1.0,tauX);
    VecRestoreSubVector( X, user -> istau, & tauX);
    VecRestoreSubVector( F, user -> istau, & tauF);

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }


  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* Set EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }

      }
    }
  }


  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArray(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }


  VecDestroy( & VxBe);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal, curlBxB, curlBxBLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);

  /* Compute the projection vectors */
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = -(P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV * V) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = -(P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV * V) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau_0 ; on all edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl((1/(L0*V_A)) * derived_mimetic_curl(B) - R_ve(VxP_fv(B))); on inner plasma faces
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl((1/(L0*V_A)) * derived_mimetic_curl(B)); on other faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        //arrF has already zeros on boundary edges

        /* f3(V,EP,tau,B,ni) = (1/(L0*V_A)) * derived_mimetic_curl(B) = (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡  (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] =  ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] =  ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] =  ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] =  ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] =  ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] -= arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] -= arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] -= arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] -= arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] -= arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV V) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV V) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]];
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]);
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau_star) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrF[ez][ephi][er][ivErmzm] - rmzpedgelength * arrF[ez][ephi][er][ivErmzp] + rmphipedgelength * arrF[ez][ephi][er][ivErmphip] - rmphimedgelength * arrF[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrF[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrF[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrF[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrF[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrF[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrF[ez][ephi][er][ivErpzm] - rmzmedgelength * arrF[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrF[ez][ephi][er][ivErpzm] - rpzpedgelength * arrF[ez][ephi][er][ivErpzp] + rpphipedgelength * arrF[ez][ephi][er][ivErpphip] - rpphimedgelength * arrF[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrF[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrF[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrF[ez][ephi][er][ivErpphip] + rmphipedgelength * arrF[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrF[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrF[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrF[ez][ephi][er][ivErpzp] - rmzpedgelength * arrF[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

      }
    }
  }
  /* End of triple for loop */



  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }


  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }

        /* Set tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);

        arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);

        arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* Set EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }

      }
    }
  }


  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArray(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }


  VecDestroy( & VxBe);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_BImplicit2(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {
  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArrayRead(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  //PetscBarrier((PetscObject) VxB);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = P_{c->v}(ni) dV/dt - P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = derived_mimetic_div(primary_mimetic_grad(EP)) + (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) -= derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArrayRead(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) = P_{c->v}(ni) dV/dt - P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];
        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[0]] - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]);
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[1]] - (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]);
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[2]] - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]);
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArrayRead(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  /*DMRestoreLocalVector(da,&fLocal);*/

  /*DMGetLocalVector(da,&fLocal);*/
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArrayRead(da, fLocal, & arrF);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArrayRead(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) += tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] += arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] += arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] += arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] += arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] += arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArrayRead(da, fLocal, & arrF);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  VecDestroy( & GradEP);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);
  VecDestroy( & VxBe);
  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da, & fLocal);
  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  //PetscBarrier((PetscObject) x);
  VecDestroy( & x);
  return (0);
}

PetscErrorCode FormIFunction_Initializepsi(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_Initializepsi",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);


  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArrayRead(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = dV/dt; on all vertices
     f2(V,EP,tau,B,ni) = -(1/r) \Delta^*(EP) + mu_0 * J_0 ; on inner vertices
     f2(V,EP,tau,B,ni) = EP ; on boundary vertices
     f3(V,EP,tau,B,ni) = dtau/dt; on all edges
     f4(V,EP,tau,B,ni) = dB/dt; on all faces
     f5(V,EP,tau,B,ni) = dni/dt; in all cells */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f1(V,EP,tau,B,ni) = dV/dt; on all vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f3(V,EP,tau,B,ni) = dtau/dt ; on all edges
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
        arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
        arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
        arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
        arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
        arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
        arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
        arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
        arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
        arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
        arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
        arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
        arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
        arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
        arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
        arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
        arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
        arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
        arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
        arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
        arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];

        //F3(V,EP,tau,B,ni) = tau - 0 ; on boundary edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrXdot[ez][ephi][er][ivErmzm];
        }
        else{
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm];
        }
        if (!(ez == 0)) {
          arrF[ez][ephi][er][ivEphimzm] = arrXdot[ez][ephi][er][ivEphimzm];
        }
        else {
          arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
        }
        if (!(er == 0)) {
          arrF[ez][ephi][er][ivErmphim] = arrXdot[ez][ephi][er][ivErmphim];
        }
        else {
          arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
        }

        if (er == N[0]-1) {
          arrF[ez][ephi][er][ivErpzm] = arrX[ez][ephi][er][ivErpzm];
          arrF[ez][ephi][er][ivErpphim] = arrX[ez][ephi][er][ivErpphim];
        }

        if (ez == N[2]-1) {
          arrF[ez][ephi][er][ivErmzp] = arrX[ez][ephi][er][ivErmzp];
          arrF[ez][ephi][er][ivEphimzp] = arrX[ez][ephi][er][ivEphimzp];
        }

        if (er == N[0]-1 && ez == N[2]-1) {
          arrF[ez][ephi][er][ivErpzp] = arrX[ez][ephi][er][ivErpzp];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm]; /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim]; /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm]; /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp]; /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip]; /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp]; /* Front face */
        }


      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  VecDestroy( & potential);

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);

  //f2(V,EP,tau,B,ni) = - (1/r) \Delta^*(EP); on inner vertices
  ApplyDeltastar2(ts, X, F, user);

  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //f2(V,EP,tau,B,ni) += mu_0 * J_0 ; on inner vertices
        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] + 1.0) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] + 1.0) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] + 1.0) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] + 1.0) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] += 1.52;
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        //arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]];
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - 0.0;
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - 0.0;
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - 0.0;
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - 0.0;
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - 0.0;
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - 0.0;
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - 0.0;
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - 0.0;
        }
      }
    }
  }

  /* Restore vectors */
  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da, & fLocal);
  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return (0);
}

PetscErrorCode FormIFunction_InitializeEP(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_InitializeEP",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);


  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArrayRead(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }


  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = dV/dt; on all vertices
     f2(V,EP,tau,B,ni) = -derived_mimetic_div(primary_mimetic_grad(EP)) - derived_mimetic_div(derived_mimetic_curl2(B)); on all vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - derived_mimetic_curl2(B); on all edges
     f4(V,EP,tau,B,ni) = dB/dt; on all faces
     f5(V,EP,tau,B,ni) = dni/dt; in all cells */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = tau */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = arrX[ez][ephi][er][ivErpzm];
          arrF[ez][ephi][er][ivErpphim] = arrX[ez][ephi][er][ivErpphim];
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = arrX[ez][ephi][er][ivEphipzm];
            arrF[ez][ephi][er][ivErmphip] = arrX[ez][ephi][er][ivErmphip];
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = arrX[ez][ephi][er][ivErmzp];
          arrF[ez][ephi][er][ivEphimzp] = arrX[ez][ephi][er][ivEphimzp];
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = arrX[ez][ephi][er][ivErpphip];
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = arrX[ez][ephi][er][ivEphipzp];
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = arrX[ez][ephi][er][ivErpzp];
        }

        /* f1(V,EP,tau,B,ni) = dV/dt; on all vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
        arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
        arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
        arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
        arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
        arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
        arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
        arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
        arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
        arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
        arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
        arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
        arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
        arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
        arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
        arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
        arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
        arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
        arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
        arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
        arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];

        /* f4(V,EP,tau,B,ni) = dB/dt */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm]; /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim]; /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm]; /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp]; /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip]; /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp]; /* Front face */
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - derived_mimetic_curl2(B) = tau - primary_mimetic_curl^T (beta_f B)/beta_e2; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae2(er, ephi, ez, BACK_LEFT, user)) ;
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae2(er, ephi, ez, BACK_DOWN, user)) ;
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user)) ;
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae2(er, ephi, ez, BACK_DOWN, user)) ;
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae2(er, ephi, ez, DOWN_LEFT, user)) ;
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);

  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  VecDestroy( & GradEP);

  DMRestoreLocalVector(da, & fLocal);
  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  //PetscBarrier((PetscObject) x);
  VecDestroy( & x);
  VecDestroy( & Fcopy);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_InitializeEP_halo(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_InitializeEP_halo",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);


  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArrayRead(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }


  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = dV/dt; on all vertices
     f2(V,EP,tau,B,ni) = -derived_mimetic_div(primary_mimetic_grad(EP)) - (1/(L0*V_A)) * derived_mimetic_div(derived_mimetic_curl(B)) = derived_mimetic_div(primary_mimetic_grad(EP)) - derived_mimetic_div(derived_mimetic_curl2(B)); on all vertices

     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - derived_mimetic_curl2(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all inner edges not inside the wall
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * der_mim_curl_etaperp(B)_perp - (1/(L0*V_A)) * der_mim_curl_etaphi(B)_phi = tau - primary_mimetic_grad(EP) - der_mim_curl2_etaperp(B)_perp - der_mim_curl2_etaphi(B)_phi; on all edges inside the wall

     f4(V,EP,tau,B,ni) = dB/dt; on all faces
     f5(V,EP,tau,B,ni) = dni/dt; in all cells */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = tau */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = arrX[ez][ephi][er][ivErpzm];
          arrF[ez][ephi][er][ivErpphim] = arrX[ez][ephi][er][ivErpphim];
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = arrX[ez][ephi][er][ivEphipzm];
            arrF[ez][ephi][er][ivErmphip] = arrX[ez][ephi][er][ivErmphip];
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = arrX[ez][ephi][er][ivErmzp];
          arrF[ez][ephi][er][ivEphimzp] = arrX[ez][ephi][er][ivEphimzp];
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = arrX[ez][ephi][er][ivErpphip];
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = arrX[ez][ephi][er][ivEphipzp];
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = arrX[ez][ephi][er][ivErpzp];
        }

        /* f1(V,EP,tau,B,ni) = dV/dt; on all vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
        arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
        arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
        arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
        arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
        arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
        arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
        arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
        arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
        arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
        arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
        arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
        arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
        arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
        arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
        arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
        arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
        arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
        arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
        arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
        arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];

        /* f4(V,EP,tau,B,ni) = dB/dt */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm]; /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim]; /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm]; /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp]; /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip]; /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp]; /* Front face */
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - derived_mimetic_curl2(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges not inside the wall
           f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * der_mim_curl_etaperp(B)_perp - (1/(L0*V_A)) * der_mim_curl_etaphi(B)_phi = tau - primary_mimetic_grad(EP) - der_mim_curl2_etaperp(B)_perp - der_mim_curl2_etaphi(B)_phi ; on all edges inside the wall */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betaephi_isolcell(er, ephi, ez, BACK_LEFT, user)) ;
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betaeperp2(er, ephi, ez, BACK_DOWN, user)) ;
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user)) ;
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betaeperp2(er, ephi, ez, BACK_DOWN, user)) ;
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betaeperp2(er, ephi, ez, DOWN_LEFT, user)) ;
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);

  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  VecDestroy( & GradEP);

  DMRestoreLocalVector(da, & fLocal);
  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  //PetscBarrier((PetscObject) x);
  VecDestroy( & x);
  VecDestroy( & Fcopy);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_InitializeEPV(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_InitializeEPV",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrniv, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;


  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V)) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V. P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt ; on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1}(\nabla^2 V)) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV1[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV1[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV1[ez][ephi][er][ivVrmphimzm[2]] - arrX[ez][ephi][er][ivVrmphimzm[1]] * arrX[ez][ephi][er][ivVrmphimzm[1]] / arrCoorda[ez][ephi][er][icrmphimzm[0]] ) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];

          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + 0.0 * arrniv[ez][ephi][er][ivVrmphimzm[0]] * (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrGradV3[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrGradV3[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrGradV3[ez][ephi][er][ivVrmphimzm[2]]) - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];

          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;

        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm]; /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim]; /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm]; /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp]; /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip]; /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp]; /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */
  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_newequilibrium(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_newequilibrium",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = P_{c->v}(n_i) (dV/dt) - P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP); on all edges
     f3(V,EP,tau,B,ni) += R_{v->e}(VxP_{f->v}(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) = P_{c->v}(n_i) (dV/dt) - P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) + Re^{-1} (\nabla^2 V) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[0]] - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];

          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[2]] - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];

          arrF[ez][ephi][er][ivVrmphimzm[1]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[1]] - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[1]] ;

        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_{v->e}(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 1.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_newequilibrium_Vperp(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_newequilibrium_Vperp",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, F1, F2, F3, GradV1, GradV1Local, GradV2, GradV2Local, GradV3, GradV3Local, Fcopy, FcopyLocal, curlBxB, curlBxBLocal, LapV, LapVLocal ;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB, ** ** arrGradV3, ** ** arrGradV2, ** ** arrGradV1, ** ** arrLapV;

  PetscInt steps=0;

  TSGetStepNumber(ts,&steps);
  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  {
    /* Compute the gradient of V */
    VecDuplicate(X, & F1);
    VecCopy(X, F1);
    VecDuplicate(X, & F2);
    VecCopy(X, F2);
    VecDuplicate(X, & F3);
    VecCopy(X, F3);
    FormDiscreteGradientVectorField(ts, X, F1, F2, F3, user);
  }
  {
    /* Compute the vector laplacian of V */
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    DMGetLocalVector(da, & LapVLocal);
    DMGlobalToLocalBegin(da, LapV, INSERT_VALUES, LapVLocal);
    DMGlobalToLocalEnd(da, LapV, INSERT_VALUES, LapVLocal);
    DMStagVecGetArrayRead(da, LapVLocal, & arrLapV);
  }
  /* Compute the projection vectors */
  /* P_{c->v}(ni) */
  DMCreateGlobalVector(da, & niv);
  CellToVertexProjectionScalar(ts, X, niv, user);
  DMGetLocalVector(da, & nivLocal);
  DMGlobalToLocalBegin(da, niv, INSERT_VALUES, nivLocal);
  DMGlobalToLocalEnd(da, niv, INSERT_VALUES, nivLocal);
  DMStagVecGetArrayRead(da, nivLocal, & arrniv);
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* P_{e->v}(prim_grad(V)) */
  DMCreateGlobalVector(da, & GradV1);
  EdgeToVertexProjection(ts, F1, GradV1, user);
  VecDestroy( & F1);
  DMGetLocalVector(da, & GradV1Local);
  DMGlobalToLocalBegin(da, GradV1, INSERT_VALUES, GradV1Local);
  DMGlobalToLocalEnd(da, GradV1, INSERT_VALUES, GradV1Local);
  DMStagVecGetArrayRead(da, GradV1Local, & arrGradV1);

  DMCreateGlobalVector(da, & GradV3);
  EdgeToVertexProjection(ts, F3, GradV3, user);
  VecDestroy( & F3);
  DMGetLocalVector(da, & GradV3Local);
  DMGlobalToLocalBegin(da, GradV3, INSERT_VALUES, GradV3Local);
  DMGlobalToLocalEnd(da, GradV3, INSERT_VALUES, GradV3Local);
  DMStagVecGetArrayRead(da, GradV3Local, & arrGradV3);

  DMCreateGlobalVector(da, & GradV2);
  EdgeToVertexProjection(ts, F2, GradV2, user);
  VecDestroy( & F2);
  DMGetLocalVector(da, & GradV2Local);
  DMGlobalToLocalBegin(da, GradV2, INSERT_VALUES, GradV2Local);
  DMGlobalToLocalEnd(da, GradV2, INSERT_VALUES, GradV2Local);
  DMStagVecGetArrayRead(da, GradV2Local, & arrGradV2);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = [P_{c->v}(n_i) (dV/dt) - P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - Re^{-1} (\nabla^2 V)] . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = [P_{c->v}(n_i) (dV/dt) - P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - Re^{-1} (\nabla^2 V)] . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP); on all edges
     f3(V,EP,tau,B,ni) += R_{v->e}(VxP_{f->v}(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = [P_{c->v}(n_i) (dV/dt) - P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - Re^{-1} (\nabla^2 V)] . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = [P_{c->v}(n_i) (dV/dt) - P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - Re^{-1} (\nabla^2 V)] . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[0]] - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[0]];

          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + arrniv[ez][ephi][er][ivVrmphimzm[0]] * arrXdot[ez][ephi][er][ivVrmphimzm[2]] - (1.0 / user->Re) * arrLapV[ez][ephi][er][ivVrmphimzm[2]];

          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]);

        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArrayRead(da, LapVLocal, & arrLapV);
  DMRestoreLocalVector(da, & LapVLocal);
  VecDestroy(& LapV);

  DMStagVecRestoreArrayRead(da, GradV1Local, & arrGradV1);
  DMRestoreLocalVector(da, & GradV1Local);
  VecDestroy( & GradV1);

  DMStagVecRestoreArrayRead(da, GradV2Local, & arrGradV2);
  DMRestoreLocalVector(da, & GradV2Local);
  VecDestroy( & GradV2);

  DMStagVecRestoreArrayRead(da, GradV3Local, & arrGradV3);
  DMRestoreLocalVector(da, & GradV3Local);
  VecDestroy( & GradV3);

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, nivLocal, & arrniv);
  DMRestoreLocalVector(da, & nivLocal);
  VecDestroy( & niv);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_{v->e}(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormIFunction_DampingV(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormIFunction_DampingV",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal, curlBxB, curlBxBLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy, ** ** arrcurlBxB;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArray(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }
  /* Compute the projection vectors */
  /* P_{c->f}(ni) */
  DMCreateGlobalVector(da, & nif);
  CellToFaceProjection(ts, X, nif, user);
  DMGetLocalVector(da, & nifLocal);
  DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
  DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
  DMStagVecGetArrayRead(da, nifLocal, & arrnif);
  /* P_{f->v}(B) */
  DMCreateGlobalVector(da, & Bv);
  FaceToVertexProjection(ts, X, Bv, user);
  DMGetLocalVector(da, & BvLocal);
  DMGlobalToLocalBegin(da, Bv, INSERT_VALUES, BvLocal);
  DMGlobalToLocalEnd(da, Bv, INSERT_VALUES, BvLocal);
  DMStagVecGetArrayRead(da, BvLocal, & arrBv);
  /* P_{e->v}(der_curl_no_mp(B)) */
  DMCreateGlobalVector(da, & curlBv);
  VecZeroEntries(curlBv);
  Vec curlB;
  VecDuplicate(X, & curlB);
  VecCopy(X, curlB);
  FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
  EdgeToVertexProjection(ts, curlB, curlBv, user);
  //PetscBarrier((PetscObject) curlB);
  VecDestroy( & curlB);
  DMGetLocalVector(da, & curlBvLocal);
  DMGlobalToLocalBegin(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMGlobalToLocalEnd(da, curlBv, INSERT_VALUES, curlBvLocal);
  DMStagVecGetArrayRead(da, curlBvLocal, & arrcurlBv);
  /* Compute the reconstruction vectors */
  /* R_{v->f}(V) */
  DMCreateGlobalVector(da, & Vf);
  VertexToFaceReconstruction(ts, X, Vf, user);
  DMGetLocalVector(da, & VfLocal);
  DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
  DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
  DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  /* R_{v->e}(VxP_{f->v}(B)) */
  DMCreateGlobalVector(da, & VxB);
  VecZeroEntries(VxB);
  VertexCrossProduct(ts, X, Bv, VxB, user);
  DMCreateGlobalVector(da, & VxBe);
  VertexToEdgeReconstruction(ts, VxB, VxBe, user);
  VecDestroy( & VxB);
  DMGetLocalVector(da, & VxBeLocal);
  DMGlobalToLocalBegin(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMGlobalToLocalEnd(da, VxBe, INSERT_VALUES, VxBeLocal);
  DMStagVecGetArrayRead(da, VxBeLocal, & arrVxBe);

  if(0){
    /* P_{e->v}(der_curl_no_mp(B)) x P_{f->v}(B) */
    DMCreateGlobalVector(da, & curlBxB);
    VecZeroEntries(curlBxB);
    VertexCrossProduct(ts, curlBv, Bv, curlBxB, user);
    DMGetLocalVector(da, & curlBxBLocal);
    DMGlobalToLocalBegin(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMGlobalToLocalEnd(da, curlBxB, INSERT_VALUES, curlBxBLocal);
    DMStagVecGetArrayRead(da, curlBxBLocal, & arrcurlBxB);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) . e_r = -(P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV * V) . e_r ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_z = -(P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV * V) . e_z ; on plasma vertices
     f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
     f1(V,EP,tau,B,ni) = V; on other vertices
     f2(V,EP,tau,B,ni) = - derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f2(V,EP,tau,B,ni) += derived_mimetic_div(R_ve(VxP_fv(B))); on plasma vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B ; on all edges
     f3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
     f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau); on all faces
     f5(V,EP,tau,B,ni) = dni/dt ; in all cells
     f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
     */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for P_{e->v}(Curl(B)) */
        if(0 && user->ictype == 10 && (ez == 0 || er == 0) ){
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = 0.0 ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoorda[ez][ephi][er][icrmphimzm[0]]))) ;
          arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] = user->eta / (user->mu0 * arrCoorda[ez][ephi][er][icrmphimzm[0]]) ;
        }

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = (tau - Eboundarycondition) */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = (arrX[ez][ephi][er][ivErmzm] - arrx[ez][ephi][er][ivErmzm]);
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = (arrX[ez][ephi][er][ivErmphim] - arrx[ez][ephi][er][ivErmphim]);
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = (arrX[ez][ephi][er][ivEphimzm] - arrx[ez][ephi][er][ivEphimzm]);
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = (arrX[ez][ephi][er][ivErpzm] - arrx[ez][ephi][er][ivErpzm]);
          arrF[ez][ephi][er][ivErpphim] = (arrX[ez][ephi][er][ivErpphim] - arrx[ez][ephi][er][ivErpphim]);
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = (arrX[ez][ephi][er][ivEphipzm] - arrx[ez][ephi][er][ivEphipzm]);
            arrF[ez][ephi][er][ivErmphip] = (arrX[ez][ephi][er][ivErmphip] - arrx[ez][ephi][er][ivErmphip]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = (arrX[ez][ephi][er][ivErmzp] - arrx[ez][ephi][er][ivErmzp]);
          arrF[ez][ephi][er][ivEphimzp] = (arrX[ez][ephi][er][ivEphimzp] - arrx[ez][ephi][er][ivEphimzp]);
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = (arrX[ez][ephi][er][ivErpphip] - arrx[ez][ephi][er][ivErpphip]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = (arrX[ez][ephi][er][ivEphipzp] - arrx[ez][ephi][er][ivEphipzp]);
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = (arrX[ez][ephi][er][ivErpzp] - arrx[ez][ephi][er][ivErpzp]);
        }

        /* f1(V,EP,tau,B,ni) . e_r = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV V) . e_r ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_z = - (P_{e->v}(der_mim_curl_no_mp(B)) x P_{f->v}(B) - dampV V) . e_z ; on plasma vertices
           f1(V,EP,tau,B,ni) . e_phi = V . P_{f->v}(B) ; on plasma vertices
           f1(V,EP,tau,B,ni) = V; on other vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           f5(V,EP,tau,B,ni) += primary_mimetic_divergence(P_{c->f}(ni)*R_{v->f}(V)); in plasma cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] += (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[2]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[1]]) + user->dampV * arrX[ez][ephi][er][ivVrmphimzm[0]];
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[0]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[0]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[2]] = - (arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[0]]) + user->dampV * arrX[ez][ephi][er][ivVrmphimzm[2]] ;
          if(0){
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrcurlBxB[ez][ephi][er][ivVrmphimzm[2]];
          }
          arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrX[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] + arrX[ez][ephi][er][ivVrmphimzm[1]] * arrBv[ez][ephi][er][ivVrmphimzm[1]] + arrX[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]);
          //arrF[ez][ephi][er][ivVrmphimzm[1]] = (arrcurlBv[ez][ephi][er][ivVrmphimzm[2]] * arrBv[ez][ephi][er][ivVrmphimzm[0]] - arrcurlBv[ez][ephi][er][ivVrmphimzm[0]] * arrBv[ez][ephi][er][ivVrmphimzm[2]]) ;
        } else if (fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) >= 0.7) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]] - arrx[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]] - arrx[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]] - arrx[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]] - arrx[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]] - arrx[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]] - arrx[ez][ephi][er][ivVrmphipzm[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]] - arrx[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]] - arrx[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]] - arrx[ez][ephi][er][ivVrmphipzp[2]];
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]] - arrx[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]] - arrx[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]] - arrx[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]] - arrx[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]] - arrx[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]] - arrx[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]] - arrx[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]] - arrx[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]] - arrx[ez][ephi][er][ivVrpphipzm[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]] - arrx[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]] - arrx[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]] - arrx[ez][ephi][er][ivVrpphipzp[2]];
        } else {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]] - arrx[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]] - arrx[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]] - arrx[ez][ephi][er][ivVrmphimzm[2]];
        }

        /* f4(V,EP,tau,B,ni) = dB/dt + primary_mimetic_curl(tau) */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm] + (rmzmedgelength * arrX[ez][ephi][er][ivErmzm] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip] - rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in F(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in F(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in F(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Brm) = %g\n", (double) arrX[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in F(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in F(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }
        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim] + (-phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim] + rmphimedgelength * arrX[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Down face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }
        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm] + (phimzmedgelength * arrX[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rmzmedgelength * arrX[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        if(0){
          PetscPrintf(PETSC_COMM_WORLD, "F(er=%d,ephi=%d,ez=%d, Bzm) = %g\n", er,ephi,ez, (double) arrF[ez][ephi][er][ivBzm]);
          PetscPrintf(PETSC_COMM_WORLD, "Xdot(er=%d,ephi=%d,ez=%d, Bzm) = %g\n", er,ephi,ez, (double) arrXdot[ez][ephi][er][ivBzm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in F(er=%d,ephi=%d,ez=%d, Bzm) = %g\n", er,ephi,ez, (double) arrX[ez][ephi][er][ivEphimzm]);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(er=%d,ephi=%d,ez=%d, Bzm) = %g\n", er,ephi,ez, (double) arrX[ez][ephi][er][ivEphipzm]);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(er=%d,ephi=%d,ez=%d, Bzm) = %g\n", er,ephi,ez, (double) arrX[ez][ephi][er][ivErpzm]);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in F(er=%d,ephi=%d,ez=%d, Bzm) = %g\n", er,ephi,ez, (double) arrX[ez][ephi][er][ivErmzm]);
        }
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "F(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp] + (rpzmedgelength * arrX[ez][ephi][er][ivErpzm] - rpzpedgelength * arrX[ez][ephi][er][ivErpzp] + rpphipedgelength * arrX[ez][ephi][er][ivErpphip] - rpphimedgelength * arrX[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip] + (-phipzmedgelength * arrX[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrX[ez][ephi][er][ivErpphip] + rmphipedgelength * arrX[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp] + (phimzpedgelength * arrX[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrX[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrX[ez][ephi][er][ivErpzp] - rmzpedgelength * arrX[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
        }

        /* Adding source term to balance the PDE: f4(B,E) = f4(B,E) - primary_mimetic_curl(potential) */
        if(user->ictype == 11 && ephi == 0){
          arrP[ez][ephi][er][ivEphimzm] = - condu(er, ephi, ez, BACK_DOWN, user) * PetscSinReal((condu(er, ephi, ez, BACK_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzm[2]] ) / user->mu0;
          arrP[ez][ephi][er][ivEphimzp] = - condu(er, ephi, ez, FRONT_DOWN, user) * PetscSinReal((condu(er, ephi, ez, FRONT_DOWN, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphimzp[2]] ) / user->mu0;
        }
        if(user->ictype == 11 && ephi == N[1]-1){
          arrP[ez][ephi][er][ivEphipzm] = - condu(er, ephi, ez, BACK_UP, user) * PetscSinReal((condu(er, ephi, ez, BACK_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzm[2]] - arrCoord[ez][ephi][er][icEphipzm[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzm[0]]))) / user->mu0;
          if(ez == N[2]-1){
            arrP[ez][ephi][er][ivEphipzp] = - condu(er, ephi, ez, FRONT_UP, user) * PetscSinReal((condu(er, ephi, ez, FRONT_UP, user) / user->mu0) * t) * (arrCoord[ez][ephi][er][icEphipzp[2]] - arrCoord[ez][ephi][er][icEphipzp[0]] * PETSC_PI * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icEphipzp[0]]))) / user->mu0;
          }
        }

        arrF[ez][ephi][er][ivBrm] -= (rmzmedgelength * arrP[ez][ephi][er][ivErmzm] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip] - rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, LEFT, user); /* Left face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Brm) = %g\n", (double) arrF[ez][ephi][er][ivBrm]);
          PetscPrintf(PETSC_COMM_WORLD, "1st term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzm]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term in Source(Brm) = %g\n", (double) rmzmedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "2nd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmzp]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 2nd term in Source(Brm) = %g\n", (double) rmzpedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "3rd term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphip]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 3rd term in Source(Brm) = %g\n", (double) rmphipedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "4th term in Source(Brm) = %g\n", (double) arrP[ez][ephi][er][ivErmphim]);
          PetscPrintf(PETSC_COMM_WORLD, "edge length in 4th term in Source(Brm) = %g\n", (double) rmphimedgelength);
          PetscPrintf(PETSC_COMM_WORLD, "surface in Source(Brm) = %g\n", (double) surface(er, ephi, ez, LEFT, user));
        }

        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivBphip] -= (-phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] - rpphipedgelength * arrP[ez][ephi][er][ivErpphip] + rmphipedgelength * arrP[ez][ephi][er][ivErmphip]) / surface(er, ephi, ez, UP, user); /* Up face */
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "Source(Bphip) = %g\n", (double) arrF[ez][ephi][er][ivBphip]);
            }
          }
        }

        arrF[ez][ephi][er][ivBphim] -= (-phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] + phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim] + rmphimedgelength * arrP[ez][ephi][er][ivErmphim]) / surface(er, ephi, ez, DOWN, user); /* Face down */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bphim) = %g\n", (double) arrF[ez][ephi][er][ivBphim]);
        }

        arrF[ez][ephi][er][ivBzm] -= (phimzmedgelength * arrP[ez][ephi][er][ivEphimzm] - phipzmedgelength * arrP[ez][ephi][er][ivEphipzm] + rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rmzmedgelength * arrP[ez][ephi][er][ivErmzm]) / surface(er, ephi, ez, BACK, user); /* Back face */
        /* DEBUG PRINT*/
        if (user -> debug) {
          PetscPrintf(PETSC_COMM_WORLD, "Source(Bzm) = %g\n", (double) arrF[ez][ephi][er][ivBzm]);
        }

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] -= (rpzmedgelength * arrP[ez][ephi][er][ivErpzm] - rpzpedgelength * arrP[ez][ephi][er][ivErpzp] + rpphipedgelength * arrP[ez][ephi][er][ivErpphip] - rpphimedgelength * arrP[ez][ephi][er][ivErpphim]) / surface(er, ephi, ez, RIGHT, user); /* Right face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Brp) = %g\n", (double) arrF[ez][ephi][er][ivBrp]);
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] -= (phimzpedgelength * arrP[ez][ephi][er][ivEphimzp] - phipzpedgelength * arrP[ez][ephi][er][ivEphipzp] + rpzpedgelength * arrP[ez][ephi][er][ivErpzp] - rmzpedgelength * arrP[ez][ephi][er][ivErmzp]) / surface(er, ephi, ez, FRONT, user); /* Front face */
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "Source(Bzp) = %g\n", (double) arrF[ez][ephi][er][ivBzp]);
          }
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]] - arrx[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]] - arrx[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]] - arrx[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]] - arrx[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]] - arrx[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]] - arrx[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]] - arrx[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]] - arrx[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  if(0){
    DMStagVecRestoreArray(da, curlBxBLocal, & arrcurlBxB);
    DMRestoreLocalVector(da, & curlBxBLocal);
    VecDestroy(& curlBxB);
  }

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
  DMRestoreLocalVector(da, & nifLocal);
  VecDestroy( & nif);

  DMStagVecRestoreArrayRead(da, BvLocal, & arrBv);
  DMRestoreLocalVector(da, & BvLocal);
  VecDestroy( & Bv);

  DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
  DMRestoreLocalVector(da, & VfLocal);
  VecDestroy( & Vf);

  DMStagVecRestoreArrayRead(da, curlBvLocal, & arrcurlBv);
  DMRestoreLocalVector(da, & curlBvLocal);
  VecDestroy( & curlBv);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
          /* DEBUG PRINT*/
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "F(Ermzm) = %E\n", (double) arrF[ez][ephi][er][ivErmzm]);
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;

            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));

              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);

              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ephimzm) = %g\n", (double) arrF[ez][ephi][er][ivEphimzm]);
            }
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
            /* DEBUG PRINT*/
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);

              PetscPrintf(PETSC_COMM_WORLD, "1st term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 1st term of F(Ermphim) = %E\n", (double)(arrX[ez][ephi][er][ivBrm]));
              PetscPrintf(PETSC_COMM_WORLD, "betaf in 1st term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "surface in 1st term of F(Ermphim) = %E\n", (double)(surface(er, ephi, ez, LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "edge length in 1st term of F(Ermphim) = %E\n", (double)(rmphimedgelength));
              PetscPrintf(PETSC_COMM_WORLD, "betae in 1st term in F(Ermphim) = %E\n", (double)(betae(er, ephi, ez, DOWN_LEFT, user)));
              PetscPrintf(PETSC_COMM_WORLD, "2nd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 2nd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi][er][ivBphim]);
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 2nd term of F(Ermphim) = %E\n", (double)(betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user)));

              PetscPrintf(PETSC_COMM_WORLD, "3rd term in F(Ermphim) = %E\n", (double)(+arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 3rd term of F(Ermphim) = %E\n", (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "B(Ermphim,%d,%d,%d) = %E\n", er, ephi - 1, ez, (double) arrX[ez][ephi - 1][er][ivBrm]);
              PetscPrintf(PETSC_COMM_WORLD, "4th term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user));
              PetscPrintf(PETSC_COMM_WORLD, "B in 4th term of F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er - 1][ivBphim]));
              PetscPrintf(PETSC_COMM_WORLD, "beta/surf in 4th term of F(Ermphim) = %E\n", (double)(betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)));
              PetscPrintf(PETSC_COMM_WORLD, "Last term in F(Ermphim) = %E\n", (double)(-arrX[ez][ephi][er][ivErmphim]));
            }
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) += R_ve(VxP_fv(B)) ; on inner plasma edges
        if (!(er == 0 || ez == 0)) {
          if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
            arrF[ez][ephi][er][ivErmzm] += arrVxBe[ez][ephi][er][ivErmzm];
          }
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0 || ephi == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        } else {
          if (!(ez == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivEphimzm] += arrVxBe[ez][ephi][er][ivEphimzm];
            }
          }
          if (!(er == 0)) {
            if ((fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) && (fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7)) {
              arrF[ez][ephi][er][ivErmphim] += arrVxBe[ez][ephi][er][ivErmphim];
            }
          }
        }
      }
    }
  }

  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
        /* Set boundary conditions for velocity */
        /* f1(V,EP,tau,B,ni) = dV/dt */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivVrmphimzm[0]] = arrXdot[ez][ephi][er][ivVrmphimzm[0]];
          arrF[ez][ephi][er][ivVrmphimzm[1]] = arrXdot[ez][ephi][er][ivVrmphimzm[1]];
          arrF[ez][ephi][er][ivVrmphimzm[2]] = arrXdot[ez][ephi][er][ivVrmphimzm[2]];
          arrF[ez][ephi][er][ivVrmphipzm[0]] = arrXdot[ez][ephi][er][ivVrmphipzm[0]];
          arrF[ez][ephi][er][ivVrmphipzm[1]] = arrXdot[ez][ephi][er][ivVrmphipzm[1]];
          arrF[ez][ephi][er][ivVrmphipzm[2]] = arrXdot[ez][ephi][er][ivVrmphipzm[2]];
        }
        if (er == 0 || ez == N[2]-1) {
          arrF[ez][ephi][er][ivVrmphimzp[0]] = arrXdot[ez][ephi][er][ivVrmphimzp[0]];
          arrF[ez][ephi][er][ivVrmphimzp[1]] = arrXdot[ez][ephi][er][ivVrmphimzp[1]];
          arrF[ez][ephi][er][ivVrmphimzp[2]] = arrXdot[ez][ephi][er][ivVrmphimzp[2]];
          arrF[ez][ephi][er][ivVrmphipzp[0]] = arrXdot[ez][ephi][er][ivVrmphipzp[0]];
          arrF[ez][ephi][er][ivVrmphipzp[1]] = arrXdot[ez][ephi][er][ivVrmphipzp[1]];
          arrF[ez][ephi][er][ivVrmphipzp[2]] = arrXdot[ez][ephi][er][ivVrmphipzp[2]];
        }
        if (ez == 0 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzm[0]] = arrXdot[ez][ephi][er][ivVrpphimzm[0]];
          arrF[ez][ephi][er][ivVrpphimzm[1]] = arrXdot[ez][ephi][er][ivVrpphimzm[1]];
          arrF[ez][ephi][er][ivVrpphimzm[2]] = arrXdot[ez][ephi][er][ivVrpphimzm[2]];
          arrF[ez][ephi][er][ivVrpphipzm[0]] = arrXdot[ez][ephi][er][ivVrpphipzm[0]];
          arrF[ez][ephi][er][ivVrpphipzm[1]] = arrXdot[ez][ephi][er][ivVrpphipzm[1]];
          arrF[ez][ephi][er][ivVrpphipzm[2]] = arrXdot[ez][ephi][er][ivVrpphipzm[2]];
        }
        if (ez == N[2]-1 || er == N[0]-1) {
          arrF[ez][ephi][er][ivVrpphimzp[0]] = arrXdot[ez][ephi][er][ivVrpphimzp[0]];
          arrF[ez][ephi][er][ivVrpphimzp[1]] = arrXdot[ez][ephi][er][ivVrpphimzp[1]];
          arrF[ez][ephi][er][ivVrpphimzp[2]] = arrXdot[ez][ephi][er][ivVrpphimzp[2]];
          arrF[ez][ephi][er][ivVrpphipzp[0]] = arrXdot[ez][ephi][er][ivVrpphipzp[0]];
          arrF[ez][ephi][er][ivVrpphipzp[1]] = arrXdot[ez][ephi][er][ivVrpphipzp[1]];
          arrF[ez][ephi][er][ivVrpphipzp[2]] = arrXdot[ez][ephi][er][ivVrpphipzp[2]];
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da,&fLocal);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);
  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  DMStagVecRestoreArrayRead(da, VxBeLocal, & arrVxBe);
  DMRestoreLocalVector(da, & VxBeLocal);


  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  VecDestroy( & GradEP);
  VecDestroy( & VxBe);
  VecDestroy( & Fcopy);
  VecDestroy( & x);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);


  return (0);
}

PetscErrorCode FormRHSFunction_BImplicit(TS ts, PetscReal t, Vec X, Vec F, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormRHSFunction_BImplicit",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal;
  Vec VxBe, VxBeLocal, VxB, Bv, BvLocal, curlBv, curlBvLocal, Vf, VfLocal, nif, nifLocal, niv, nivLocal;
  Vec x;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[3], ivVrmphimzp[3], ivVrmphipzm[3], ivVrmphipzp[3];
  PetscInt ivVrpphimzm[3], ivVrpphipzm[3], ivVrpphipzp[3], ivVrpphimzp[3];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrBv, ** ** arrcurlBv, ** ** arrVxBe, ** ** arrnif, ** ** arrniv, ** ** arrVf;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 3; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }


  if(0){
    /* Compute the exact solution to set boundary conditions */
    DMCreateGlobalVector(da, & x);
    FormExactSolution(t, ts, & x, user);
    DMGetLocalVector(da, & bcLocal);
    DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
    DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
    DMStagVecGetArrayRead(da, bcLocal, & arrx);
    TSGetTimeStep(ts, & dt);

    /* Compute the projection vectors */
    /* P_{c->f}(ni) */
    DMCreateGlobalVector(da, & nif);
    CellToFaceProjection(ts, X, nif, user);
    DMGetLocalVector(da, & nifLocal);
    DMGlobalToLocalBegin(da, nif, INSERT_VALUES, nifLocal);
    DMGlobalToLocalEnd(da, nif, INSERT_VALUES, nifLocal);
    DMStagVecGetArrayRead(da, nifLocal, & arrnif);
    /* Compute the reconstruction vectors */
    /* R_{v->f}(V) */
    DMCreateGlobalVector(da, & Vf);
    VertexToFaceReconstruction(ts, X, Vf, user);
    DMGetLocalVector(da, & VfLocal);
    DMGlobalToLocalBegin(da, Vf, INSERT_VALUES, VfLocal);
    DMGlobalToLocalEnd(da, Vf, INSERT_VALUES, VfLocal);
    DMStagVecGetArrayRead(da, VfLocal, & arrVf);
  }

  /*Compute function over the locally owned part of the grid */
  /* f1(V,E,B,ni) = 0 ; on all vertices
     f2(V,E,B,ni) = 0; on all edges
     f3(V,E,B,ni) = 0; on all faces
     f4(V,E,B,ni) = - primary_mimetic_div(P_cf(ni)R_vf(V)); in plasma cells
     f4(V,E,B,ni) = 0; in other cells */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f1(V,E,B,ni) = 0; on all vertices

           f4(V,E,B,ni) = - prim_div(P_{c->f}(ni)R_{v->f}(V)); in plasma cells
           f4(V,E,B,ni) = 0; in wall cells
           */
        arrF[ez][ephi][er][ivn] = 0.0;
        if (0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7) {
          arrF[ez][ephi][er][ivn] -= (-surface(er, ephi, ez, LEFT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrm] * arrVf[ez][ephi][er][ivBrm] + (surface(er, ephi, ez, RIGHT, user) / cellvolume) * arrnif[ez][ephi][er][ivBrp] * arrVf[ez][ephi][er][ivBrp] + (-surface(er, ephi, ez, DOWN, user) / cellvolume) * arrnif[ez][ephi][er][ivBphim] * arrVf[ez][ephi][er][ivBphim] + (surface(er, ephi, ez, UP, user) / cellvolume) * arrnif[ez][ephi][er][ivBphip] * arrVf[ez][ephi][er][ivBphip] + (-surface(er, ephi, ez, BACK, user) / cellvolume) * arrnif[ez][ephi][er][ivBzm] * arrVf[ez][ephi][er][ivBzm] + (surface(er, ephi, ez, FRONT, user) / cellvolume) * arrnif[ez][ephi][er][ivBzp] * arrVf[ez][ephi][er][ivBzp];
        }

        arrF[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
        arrF[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
        arrF[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

        arrF[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
        arrF[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
        arrF[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

        arrF[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
        arrF[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
        arrF[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

        arrF[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
        arrF[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
        arrF[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

        arrF[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
        arrF[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
        arrF[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

        arrF[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
        arrF[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
        arrF[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

        arrF[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
        arrF[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
        arrF[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

        arrF[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
        arrF[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
        arrF[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

        if (user -> ictype == 12 && er!=0 && ez!=0) {
          /* curlB x B = - (1/r) * (cos(2*r_max/r)*(exp(- z / z_max)/z_max + 2*r_max*sin(2*r_max/r)/r) + (r-z)*(2*r-z)) e_r +
             (- cos(2*r_max/r) + (2r-z) * exp(-z/z_max)/r^2) e_phi +
             (-z+r + exp(-z/z_max)/r * (exp(-z/z_max)/(r*z_max) + sin(2*r_max/r)* 2r_max/r^2) )e_z */
          if (er > 0 && ez > 0 && fabs(user -> dataC[er + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + ez * N[1] * N[0]] - 1.5) < 0.7 && fabs(user -> dataC[er - 1 + ephi * N[0] + (ez - 1) * N[1] * N[0]] - 1.5) < 0.7) {
            arrF[ez][ephi][er][ivVrmphimzm[0]] = -(1.0/ arrCoord[ez][ephi][er][icrmphimzm[0]]) * (PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icrmphimzm[0]]) * (PetscExpReal(- arrCoord[ez][ephi][er][icrmphimzm[2]] / user->zmax) / user->zmax + PetscSinReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icrmphimzm[0]]) * 2.0 * user->rmax / arrCoord[ez][ephi][er][icrmphimzm[0]]) + (arrCoord[ez][ephi][er][icrmphimzm[0]] - arrCoord[ez][ephi][er][icrmphimzm[2]]) * (2.0 * arrCoord[ez][ephi][er][icrmphimzm[0]] - arrCoord[ez][ephi][er][icrmphimzm[2]]) ) ;
            arrF[ez][ephi][er][ivVrmphimzm[1]] = - PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icrmphimzm[0]]) + PetscExpReal(- arrCoord[ez][ephi][er][icrmphimzm[2]] / user->zmax) * (2.0 * arrCoord[ez][ephi][er][icrmphimzm[0]] - arrCoord[ez][ephi][er][icrmphimzm[2]]) / PetscSqr(arrCoord[ez][ephi][er][icrmphimzm[0]]);
            arrF[ez][ephi][er][ivVrmphimzm[2]] = arrCoord[ez][ephi][er][icrmphimzm[0]] - arrCoord[ez][ephi][er][icrmphimzm[2]] + ( PetscExpReal(- arrCoord[ez][ephi][er][icrmphimzm[2]] / user->zmax) / (user->zmax * arrCoord[ez][ephi][er][icrmphimzm[0]]) + PetscSinReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icrmphimzm[0]]) * 2.0 * user->rmax / PetscSqr(arrCoord[ez][ephi][er][icrmphimzm[0]]) ) * PetscExpReal(- arrCoord[ez][ephi][er][icrmphimzm[2]] / user->zmax) / arrCoord[ez][ephi][er][icrmphimzm[0]];
          }
        }

        /* f3(B,E) = 0 */
        arrF[ez][ephi][er][ivBrm] = 0.0;
        arrF[ez][ephi][er][ivBphim] = 0.0;
        arrF[ez][ephi][er][ivBzm] = 0.0;
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = 0.0;
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = 0.0;
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = 0.0;
        }

        /* f2(B,E) = 0; for edges outside of the plasma region and the wall/plasma interface */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = 0.0;
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = 0.0;
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = 0.0;
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = 0.0;
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = 0.0;
          }
        }

      }
    }
  }
  /* End of triple for loop */

  /* Restore vectors */
  if(0){
    DMStagVecRestoreArrayRead(da, nifLocal, & arrnif);
    DMRestoreLocalVector(da, & nifLocal);
    VecDestroy( & nif);

    DMStagVecRestoreArrayRead(da, VfLocal, & arrVf);
    DMRestoreLocalVector(da, & VfLocal);
    VecDestroy( & Vf);

    DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
    DMRestoreLocalVector(da, & bcLocal);
    //PetscBarrier((PetscObject) x);
    VecDestroy( & x);
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
  DMRestoreLocalVector(da, & fLocal);
  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return (0);
}

PetscErrorCode FormInitialSolution(TS ts, Vec X, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormInitialSolution",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da;
  PetscInt startr, startphi, startz, nr, nphi, nz;

  Vec xLocal;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];

  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];
  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  PetscScalar ** ** arrCoord, ** ** arrX, time = 0.0;
  PetscInt countz = 0, countphi = 0, countr = 0;

  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  for (d = 0; d < 3; ++d) {
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
  }

  if(0 && user->ictype == 9 && user->itime == 0.0){
    char filename[PETSC_MAX_PATH_LEN];
    PetscViewer viewerX;

    /* Read X in binary file */
    PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, 2, 0.23);
    PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
    PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
    VecLoad(X, viewerX);
    /* Destroy the viewer */
    PetscViewerDestroy( & viewerX);
    PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
  }
  if (1) {
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       Cancel all components except B
       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    Vec tau, EP, ni, Vi_perp;
    VecGetSubVector( X, user -> isEP, & EP);
    VecScale(EP, 0.0);
    VecRestoreSubVector( X, user -> isEP, & EP);
    VecGetSubVector( X, user -> istau, & tau);
    VecScale(tau, 0.0);
    VecRestoreSubVector( X, user -> istau, & tau);
    VecGetSubVector( X, user -> isni, & ni);
    VecScale(ni, 0.0);
    VecRestoreSubVector( X, user -> isni, & ni);
    VecGetSubVector( X, user -> isV, & Vi_perp);
    VecScale(Vi_perp, 0.0);
    VecRestoreSubVector( X, user -> isV, & Vi_perp);
  }
  /* Compute function over the locally owned part of the grid */
  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        if (user -> ictype == 1) {
          /* B(r, phi, z, t) = (cos(pi*t)/r) * ((z-0.5)^2 + sin(phi)) e_r */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrm[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrm[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrp[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrp[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = (cos(pi*t)*(2*z-1)/r) e_phi - (cos(pi*t)*cos(phi)/r^2) e_z */
          arrX[ez][ephi][er][ivErmzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzm[0]];
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphim[0]]);

          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzm[0]];
            arrX[ez][ephi][er][ivErpphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzp[0]];
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzp[0]];
          }
        } else if (user -> ictype == 2) {
          /* B(r, phi, z, t=0) = sin(pi*r) e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphim[0]]);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = (pi*cos(pi*r) + sin(pi*r)/r) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) / arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) / arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) / arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) / arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 3) {
          /* B(r, phi, z, t=0) = cos(phi) e_r - sin(phi) e_phi */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(arrCoord[ez][ephi][er][icBrm[1]]);
          arrX[ez][ephi][er][ivBphim] = -PetscSinReal(arrCoord[ez][ephi][er][icBphim[1]]);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(arrCoord[ez][ephi][er][icBrp[1]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = -PetscSinReal(arrCoord[ez][ephi][er][icBphip[1]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 4) {
          /* B(r, phi, z, t=0) = e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 1.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 1.0;
          }
          /* E(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 5) {
          /* B(r, phi, z, t=0) = (1/r) e_r */
          arrX[ez][ephi][er][ivBrm] = 1.0 / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 1.0 / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 6) {
          /* B(r, phi, z, t=0) = e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 1.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = (1/r) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 1.0 / arrCoord[ez][ephi][er][icErmphim[0]];
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 1.0 / arrCoord[ez][ephi][er][icErpphim[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 1.0 / arrCoord[ez][ephi][er][icErmphip[0]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 1.0 / arrCoord[ez][ephi][er][icErpphip[0]];
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 7) {
          /* B(r, phi, z, t=0) = (1 + sin(phi)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) + 1.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) + 1.0;
          }
          /* E(r, phi, z, t=0) = (cos(phi)/r) e_r */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]) / arrCoord[ez][ephi][er][icEphimzm[0]];
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]) / arrCoord[ez][ephi][er][icEphipzm[0]];
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]) / arrCoord[ez][ephi][er][icEphimzp[0]];
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]) / arrCoord[ez][ephi][er][icEphipzp[0]];
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 8) {
          /* B(r, phi, z, t=0) = exp(sin(phi)*r) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) * arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) * arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* E(r, phi, z, t=0) = exp(sin(phi)*r) * (cos(phi) e_r - sin(phi) e_phi) */
          arrX[ez][ephi][er][ivErmzm] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]) * arrCoord[ez][ephi][er][icErmzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]);
          arrX[ez][ephi][er][ivEphimzm] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphimzm[1]]) * arrCoord[ez][ephi][er][icEphimzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]);
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]) * arrCoord[ez][ephi][er][icErpzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]);
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphipzm[1]]) * arrCoord[ez][ephi][er][icEphipzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]);
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]) * arrCoord[ez][ephi][er][icErmzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]);
            arrX[ez][ephi][er][ivEphimzp] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphimzp[1]]) * arrCoord[ez][ephi][er][icEphimzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]);
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphipzp[1]]) * arrCoord[ez][ephi][er][icEphipzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]);
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]) * arrCoord[ez][ephi][er][icErpzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]);
          }
        } else if (user -> ictype == 10) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 1.0;
          arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) = 0 */
          /*
             arrX[ez][ephi][er][ivErmzm] = 0.0;
             arrX[ez][ephi][er][ivEphimzm] = 0.0;
             arrX[ez][ephi][er][ivErmphim] = 0.0;
             if (er == N[0] - 1) {
             arrX[ez][ephi][er][ivErpzm] = 0.0;
             arrX[ez][ephi][er][ivErpphim] = 0.0;
             }
             if (ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivEphipzm] = 0.0;
             arrX[ez][ephi][er][ivErmphip] = 0.0;
             }
             if (ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErmzp] = 0.0;
             arrX[ez][ephi][er][ivEphimzp] = 0.0;
             }
             if (er == N[0] - 1 && ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivErpphip] = 0.0;
             }
             if (ephi == N[1] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivEphipzp] = 0.0;
             }
             if (er == N[0] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErpzp] = 0.0;
             }*/

          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        } else if (user -> ictype == 9 && user -> itime == 0.0) {
          if(1){
            /* B(r, phi, z, t=0) Loaded from ReadInitialData output */
            arrX[ez][ephi][er][ivBrm] = user -> datar[er + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1)] / user->B0;
            countr = countr + 1;
            //PetscPrintf(PETSC_COMM_SELF,"arrX[%d][%d][%d][%d] = %15.10e\n",ez,ephi,er,ivBrm,arrX[ez][ephi][er][ivBrm]);

            arrX[ez][ephi][er][ivBphim] = user -> dataphi[er + ephi * N[0] + ez * N[0] * (N[1] + 1)] / user->B0;
            countphi = countphi + 1;
            //PetscPrintf(PETSC_COMM_SELF,"arrX[%d][%d][%d][%d] = %15.10e\n",ez,ephi,er,ivBphim,arrX[ez][ephi][er][ivBphim]);

            arrX[ez][ephi][er][ivBzm] = user -> dataz[er + ephi * N[0] + ez * N[0] * N[1]] / user->B0;
            countz = countz + 1;
            //PetscPrintf(PETSC_COMM_SELF,"arrX[%d][%d][%d][%d] = %15.10e\n",ez,ephi,er,ivBzm,arrX[ez][ephi][er][ivBzm]);

            if (er == N[0] - 1) {
              arrX[ez][ephi][er][ivBrp] = user -> datar[er + 1 + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1)] / user->B0;
              countr = countr + 1;
              //PetscPrintf(PETSC_COMM_SELF,"arrX[%d][%d][%d][%d] = %15.10e\n",ez,ephi,er,ivBrp,arrX[ez][ephi][er][ivBrp]);
            }
            if (ephi == N[1] - 1) {
              arrX[ez][ephi][er][ivBphip] = user -> dataphi[er + (ephi + 1) * N[0] + ez * N[0] * (N[1] + 1)] / user->B0;
              countphi = countphi + 1;
              //PetscPrintf(PETSC_COMM_SELF,"arrX[%d][%d][%d][%d] = %15.10e\n",ez,ephi,er,ivBphip,arrX[ez][ephi][er][ivBphip]);
            }
            if (ez == N[2] - 1) {
              arrX[ez][ephi][er][ivBzp] = user -> dataz[er + ephi * N[0] + (ez + 1) * N[0] * N[1]] / user->B0;
              countz = countz + 1;
              //PetscPrintf(PETSC_COMM_SELF,"arrX[%d][%d][%d][%d] = %15.10e\n",ez,ephi,er,ivBzp,arrX[ez][ephi][er][ivBzp]);
            }

            if (countr > user -> numr) printf("countr = [%d] exceeds numr = [%d]\n", countr, user -> numr);
            if (countphi > user -> numphi) printf("countphi = [%d] exceeds numphi = [%d]\n", countphi, user -> numphi);
            if (countz > user -> numz) printf("countz = [%d] exceeds numz = [%d]\n", countz, user -> numz);
          }
          /* tau(r, phi, z, t=0) initialized with zero values. The tau field will be computed later from B field with the derived curl operator */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        } else if (user -> ictype == 11) {
          /* B(r, phi, z, t=0) = (2+cos(eta/mu0 * t)) * [e_phi + sqrt(2*ln(2*r_max/r)) e_z] */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          arrX[ez][ephi][er][ivBzm] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) * (cos(eta/mu0 * t)+2) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, BACK_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, DOWN_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, BACK_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, DOWN_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, UP_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, FRONT_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, UP_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, FRONT_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }
        else if (user -> ictype == 12) {
          /* B(r, phi, z, t=0) = exp(- z / z_max) / r e_r + (r - z) e_phi + cos(2*r_max/r) e_z */
          arrX[ez][ephi][er][ivBrm] = PetscExpReal(- arrCoord[ez][ephi][er][icBrm[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = arrCoord[ez][ephi][er][icBphim[0]] - arrCoord[ez][ephi][er][icBphim[2]];
          arrX[ez][ephi][er][ivBzm] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscExpReal(- arrCoord[ez][ephi][er][icBrp[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = arrCoord[ez][ephi][er][icBphip[0]] - arrCoord[ez][ephi][er][icBphip[2]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        else if (user -> ictype == 13) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          if(er!=0) {
            arrX[ez][ephi][er][ivBrm] = 0.0;
          }
          arrX[ez][ephi][er][ivBphim] = 1.0;
          if(ez!=0) {
            arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          }
          if(er==0) {
            arrX[ez][ephi][er][ivBrm] = NAN;
          }
          if(ez==0) {
            arrX[ez][ephi][er][ivBzm] = NAN;
          }
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = NAN;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = NAN;
          }
          /* tau(r, phi, z, t=0) = 0 */
          /*
             arrX[ez][ephi][er][ivErmzm] = 0.0;
             arrX[ez][ephi][er][ivEphimzm] = 0.0;
             arrX[ez][ephi][er][ivErmphim] = 0.0;
             if (er == N[0] - 1) {
             arrX[ez][ephi][er][ivErpzm] = 0.0;
             arrX[ez][ephi][er][ivErpphim] = 0.0;
             }
             if (ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivEphipzm] = 0.0;
             arrX[ez][ephi][er][ivErmphip] = 0.0;
             }
             if (ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErmzp] = 0.0;
             arrX[ez][ephi][er][ivEphimzp] = 0.0;
             }
             if (er == N[0] - 1 && ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivErpphip] = 0.0;
             }
             if (ephi == N[1] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivEphipzp] = 0.0;
             }
             if (er == N[0] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErpzp] = 0.0;
             }*/

          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }
        else if (user -> ictype > 13) PetscPrintf(PETSC_COMM_WORLD, "Test case not set\n");

      }
    }
  }

  /* Restore vectors */
  DMStagVecRestoreArray(da, xLocal, & arrX);
  if (user -> itime == 0.0) {
    DMLocalToGlobal(da, xLocal, INSERT_VALUES, X);
    DMRestoreLocalVector(da, & xLocal);
  } else {
    char filename[PETSC_MAX_PATH_LEN];
    PetscViewer viewerX;

    /* Read X in binary file */
    PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, (int)(user -> oldstep), (double) user -> itime);
    PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
    PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
    VecLoad(X, viewerX);
    /* Destroy the viewer */
    PetscViewerDestroy( & viewerX);
    PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
  }

  if (0 && user -> ictype == 10 && user -> itime == 0.0) {
    Vec Xcopy;
    VecDuplicate(X, & Xcopy);
    VecCopy(X, Xcopy);
    VecScale(Xcopy, 1.0 / user->V_A);
    FormDerivedCurl(ts, Xcopy, X, user); //This updates only the tau field part in X by computing the derived mimetic curl operator applied to B field of Xcopy
                                         //PetscBarrier((PetscObject) Xcopy);
    VecDestroy( & Xcopy);
  }

  if ((user -> ictype == 9 || user -> ictype == 15) && user -> itime == 0.0) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);

    TSSetProblemType(dummyts, TS_LINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSSetType(dummyts, TSBEULER);
    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_InitializeEP, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    TSSetTime(dummyts, 0.0);
    TSSetMaxTime(dummyts, 1e-2);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 1e-2);
    TSSetSolution(dummyts, X);

    //TSGetSNES(dummyts, & dummysnes);
    //SNESGetKSP(dummysnes, & dummyKSP);
    TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);
    //PCSetType(dummypc, PCNONE);

    PCSetType(dummypc,PCBJACOBI);
    //PCASMSetOverlap(dummypc,7);
    //PCFactorSetMatSolverType(dummypc,MATSOLVERMUMPS);
    //PCFactorSetUpMatSolverType(dummypc);


    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      //PetscCall(KSPGetPC(dummyKSP,&dummypc));
      //PetscCall(PCSetType(dummypc,PCFIELDSPLIT));

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;
        PetscBool is_fieldsplit;

        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      {
        PCType pc_type;
        PetscBool is_fieldsplit;

        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_velocity[3], stencil_noe_notvelocity[4];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EB", "V"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is faces and 4th dofs on vertices
          stencil_noe_notvelocity[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_notvelocity[0].c = 3;

          stencil_noe_notvelocity[1].loc = DMSTAG_LEFT;
          stencil_noe_notvelocity[1].c = 0;
          stencil_noe_notvelocity[2].loc = DMSTAG_BACK;
          stencil_noe_notvelocity[2].c = 0;
          stencil_noe_notvelocity[3].loc = DMSTAG_DOWN;
          stencil_noe_notvelocity[3].c = 0;

          // Second split within notv is the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_velocity[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_velocity[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_noe,4,stencil_noe_notvelocity,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,3,stencil_noe_velocity,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      {
        PCType pc_type;
        PetscBool is_fieldsplit;

        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;
          PC            pc_noe_2;
          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"EP", "B"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[0],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,1,0,1,0,&dm_notv));

          // First split within notv is the 4th dofs on vertices
          stencil_notv_notfaces[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notv_notfaces[0].c = 0;

          // Second split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notv,1,stencil_notv_notfaces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-8,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);

    TSSolve(dummyts, X);

    // if(0){
    // KSPConvergedReasonView(dummyKSP, PETSC_VIEWER_DEFAULT);
    // KSPMonitorSet(dummyKSP, (PetscErrorCode (*)(KSP,PetscInt,PetscReal,void*))KSPMonitorResidual, NULL, NULL);
    // KSPView(dummyKSP, PETSC_VIEWER_STDOUT_WORLD);
    // }

    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
  }

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  if (user -> debug) {
    /*This print is just for debugging*/
    PetscPrintf(PETSC_COMM_WORLD, "Initial solution vector\n");
    VecView(X, PETSC_VIEWER_STDOUT_WORLD);
  }

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return (0);
}

PetscErrorCode FormExactSolution(PetscReal time, TS ts, Vec * X, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormExactSolution",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da;
  PetscInt startr, startphi, startz, nr, nphi, nz;

  Vec xLocal;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];

  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];
  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  PetscScalar ** ** arrCoord, ** ** arrX, dt;
  PetscInt countz = 0, countphi = 0, countr = 0;

  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  for (d = 0; d < 3; ++d) {
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
  }
  /* Compute function over the locally owned part of the grid */
  DMGetLocalVector(da, & xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);
  TSGetTimeStep(ts, & dt);
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        if (user -> ictype == 1) {
          /* B(r, phi, z, t) = (cos(pi*t)/r) * ((z-0.5)^2 + sin(phi)) e_r */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrm[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrm[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrp[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrp[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = (cos(pi*t)*(2*z-1)/r) e_phi - (cos(pi*t)*cos(phi)/r^2) e_z */
          arrX[ez][ephi][er][ivErmzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzm[0]];
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzm[0]];
            arrX[ez][ephi][er][ivErpphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzp[0]];
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzp[0]];
          }
        }
        if (user -> ictype == 2) {
          /* B(r, phi, z, t) = sin(pi*r) exp(-t) e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphim[0]]) * PetscExpReal(-time);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphip[0]]) * PetscExpReal(-time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = (pi*cos(pi*r) + sin(pi*r)/r) exp(-t) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) / arrCoord[ez][ephi][er][icErmphim[0]]) * PetscExpReal(-time);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) / arrCoord[ez][ephi][er][icErpphim[0]]) * PetscExpReal(-time);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) / arrCoord[ez][ephi][er][icErmphip[0]]) * PetscExpReal(-time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) / arrCoord[ez][ephi][er][icErpphip[0]]) * PetscExpReal(-time);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 3) {
          /* B(r, phi, z, t) = cos(phi) e_r - sin(phi) e_phi */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(arrCoord[ez][ephi][er][icBrm[1]]);
          arrX[ez][ephi][er][ivBphim] = -PetscSinReal(arrCoord[ez][ephi][er][icBphim[1]]);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(arrCoord[ez][ephi][er][icBrp[1]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = -PetscSinReal(arrCoord[ez][ephi][er][icBphip[1]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 4) {
          /* B(r, phi, z, t) = e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 1.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 1.0;
          }
          /* E(r, phi, z, t) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 5) {
          /* B(r, phi, z, t) = (1/r) e_r */
          arrX[ez][ephi][er][ivBrm] = 1.0 / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 1.0 / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 6) {
          /* B(r, phi, z, t<=t_1) = (1 - t/r^2) e_phi */
          /* B(r, phi, z, t_1<t<=t_2) = (1 - 2dt/r^2 + time/r^2 - 3(time^2 - dt^2)/(2r^4) ) e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          /*arrX[ez][ephi][er][ivBphim] = 1.0 - time / PetscPowReal(arrCoord[ez][ephi][er][icBphim[0]],2) ;*/
          arrX[ez][ephi][er][ivBphim] = 1.0 - (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icBphim[0]], 2) - (time > 0.0) * 3.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icBphim[0]], 4));
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "X_exact(Bphim) = %g\n", (double) arrX[ez][ephi][er][ivBphim]);
          }
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            /*arrX[ez][ephi][er][ivBphip] = 1.0 - time / PetscPowReal(arrCoord[ez][ephi][er][icBphip[0]],2) ;*/
            arrX[ez][ephi][er][ivBphip] = 1.0 - (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icBphip[0]], 2) - (time > 0.0) * 3.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icBphip[0]], 4));
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t<=t_1) = (1/r + t/r^3) e_z */
          /* E(r, phi, z, t<=t_2) = (1/r + 2dt/r^3 - time/r^3 + 9(time^2 - dt^2)/(2r^5) ) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          /*arrX[ez][ephi][er][ivErmphim] = 1.0 / arrCoord[ez][ephi][er][icErmphim[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErmphim[0]],3) ; */
          arrX[ez][ephi][er][ivErmphim] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErmphim[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErmphim[0]], 4))) / arrCoord[ez][ephi][er][icErmphim[0]];
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            /*arrX[ez][ephi][er][ivErpphim] = 1.0 / arrCoord[ez][ephi][er][icErpphim[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErpphim[0]],3);*/
            arrX[ez][ephi][er][ivErpphim] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErpphim[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErpphim[0]], 4))) / arrCoord[ez][ephi][er][icErpphim[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            /*arrX[ez][ephi][er][ivErmphip] = 1.0 / arrCoord[ez][ephi][er][icErmphip[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErmphip[0]],3);*/
            arrX[ez][ephi][er][ivErmphip] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErmphip[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErmphip[0]], 4))) / arrCoord[ez][ephi][er][icErmphip[0]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            /*arrX[ez][ephi][er][ivErpphip] = 1.0 / arrCoord[ez][ephi][er][icErpphip[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErpphip[0]],3);*/
            arrX[ez][ephi][er][ivErpphip] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErpphip[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErpphip[0]], 4))) / arrCoord[ez][ephi][er][icErpphip[0]];
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 7) {
          /* B(r, phi, z, t) = (cos(pi*t) + sin(phi)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) + PetscCosReal(PETSC_PI * time);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) + PetscCosReal(PETSC_PI * time);
          }
          /* E(r, phi, z, t) = (cos(phi)/r) e_r */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]) / arrCoord[ez][ephi][er][icEphimzm[0]];
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]) / arrCoord[ez][ephi][er][icEphipzm[0]];
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]) / arrCoord[ez][ephi][er][icEphimzp[0]];
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]) / arrCoord[ez][ephi][er][icEphipzp[0]];
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 8) {
          /* B(r, phi, z, t) = exp(sin(phi)*r+t) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) * arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) * arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* E(r, phi, z, t) = exp(sin(phi)*r+t) * (cos(phi) e_r - sin(phi) e_phi) */
          arrX[ez][ephi][er][ivErmzm] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]) * arrCoord[ez][ephi][er][icErmzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]);
          arrX[ez][ephi][er][ivEphimzm] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphimzm[1]]) * arrCoord[ez][ephi][er][icEphimzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]);
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]) * arrCoord[ez][ephi][er][icErpzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]);
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphipzm[1]]) * arrCoord[ez][ephi][er][icEphipzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]);
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]) * arrCoord[ez][ephi][er][icErmzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]);
            arrX[ez][ephi][er][ivEphimzp] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphimzp[1]]) * arrCoord[ez][ephi][er][icEphimzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]);
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphipzp[1]]) * arrCoord[ez][ephi][er][icEphipzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]);
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]) * arrCoord[ez][ephi][er][icErpzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]);
          }
        }

        if (user -> ictype == 9) {
          /* B(r, phi, z, t=0) Loaded from ReadInitialData output */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          countr = countr + 1;

          arrX[ez][ephi][er][ivBphim] = 0.0;
          countphi = countphi + 1;

          arrX[ez][ephi][er][ivBzm] = 0.0;
          countz = countz + 1;

          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
            countr = countr + 1;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
            countphi = countphi + 1;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
            countz = countz + 1;
          }

          //if (countr > user -> numr) printf("countr = [%d] exceeds numr = [%d]\n", countr, user -> numr);
          //if (countphi > user -> numphi) printf("countphi = [%d] exceeds numphi = [%d]\n", countphi, user -> numphi);
          //if (countz > user -> numz) printf("countz = [%d] exceeds numz = [%d]\n", countz, user -> numz);
          /* tau(r, phi, z, t=0) initialized with zero values. The E field will be computed later from B field with the derived curl operator */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 10) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 1.0;
          arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) initialized with zero values. The tau field can be computed later from B field with the derived curl operator */
          /*arrX[ez][ephi][er][ivErmzm] = 0.0;
            arrX[ez][ephi][er][ivEphimzm] = 0.0;
            arrX[ez][ephi][er][ivErmphim] = 0.0;
            if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
            }
            if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
            }
            if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
            }
            if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
            }
            if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
            }
            if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
            }*/
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 11) {
          /* B(r, phi, z, t=0) = [2+cos(eta/mu0 * t)] * [e_phi + sqrt(2*ln(2*r_max/r)) e_z] */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          arrX[ez][ephi][er][ivBzm] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) * (cos(eta/mu0 * t) + 2)/r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          if(er == 0 || ez == 0){
            arrX[ez][ephi][er][ivErmzm] = 0.0;
          }
          else{
            arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, BACK_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          }
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          if((ephi == 0 && !user->phibtype) || er == 0){
            arrX[ez][ephi][er][ivErmphim] = 0.0;
          }
          else{
            arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, DOWN_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          }
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, UP_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 12) {
          /* B(r, phi, z, t=0) = exp(- z / z_max) / r e_r + (r - z) e_phi + cos(2*r_max/r) e_z */
          arrX[ez][ephi][er][ivBrm] = PetscExpReal(- arrCoord[ez][ephi][er][icBrm[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = arrCoord[ez][ephi][er][icBphim[0]] - arrCoord[ez][ephi][er][icBphim[2]];
          arrX[ez][ephi][er][ivBzm] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscExpReal(- arrCoord[ez][ephi][er][icBrp[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = arrCoord[ez][ephi][er][icBphip[0]] - arrCoord[ez][ephi][er][icBphip[2]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 13) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          if(er!=0) {
            arrX[ez][ephi][er][ivBrm] = 0.0;
          }
          arrX[ez][ephi][er][ivBphim] = 1.0;
          if(ez!=0) {
            arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          }
          if(er==0) {
            arrX[ez][ephi][er][ivBrm] = NAN;
          }
          if(ez==0) {
            arrX[ez][ephi][er][ivBzm] = NAN;
          }
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = NAN;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = NAN;
          }
          /* tau(r, phi, z, t=0) = 0 */
          /*
             arrX[ez][ephi][er][ivErmzm] = 0.0;
             arrX[ez][ephi][er][ivEphimzm] = 0.0;
             arrX[ez][ephi][er][ivErmphim] = 0.0;
             if (er == N[0] - 1) {
             arrX[ez][ephi][er][ivErpzm] = 0.0;
             arrX[ez][ephi][er][ivErpphim] = 0.0;
             }
             if (ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivEphipzm] = 0.0;
             arrX[ez][ephi][er][ivErmphip] = 0.0;
             }
             if (ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErmzp] = 0.0;
             arrX[ez][ephi][er][ivEphimzp] = 0.0;
             }
             if (er == N[0] - 1 && ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivErpphip] = 0.0;
             }
             if (ephi == N[1] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivEphipzp] = 0.0;
             }
             if (er == N[0] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErpzp] = 0.0;
             }*/

          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }
      }
    }
  }
  /* Restore vectors */
  DMStagVecRestoreArray(da, xLocal, & arrX);
  DMLocalToGlobal(da, xLocal, INSERT_VALUES, * X);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);

  if (user -> ictype == 9 && user -> Ebc) {
    Vec Xcopy;
    VecDuplicate( * X, & Xcopy);
    VecCopy( * X, Xcopy);
    VecScale(Xcopy, 1.0 / 11000000.0);
    FormDerivedCurl(ts, Xcopy, * X, user); //This updates only the E field part in X by computing the derived mimetic curl operator applied to B field of Xcopy
                                           //PetscBarrier((PetscObject) Xcopy);
    VecDestroy( & Xcopy);
  }

  if (0) {
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       Normalize the system
       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    Vec B, E, ni, Vi_perp;
    VecGetSubVector( * X, user -> isB, & B);
    VecScale(B, 0.2); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( * X, user -> isB, & B);
    VecGetSubVector( * X, user -> istau, & E);
    VecScale(E, 0.2); // E := tilde{E} = (E_0^-1) E
    VecScale(E, 1.0 / 11000000); // E := tilde{E} = (E_0^-1) E
    VecRestoreSubVector( * X, user -> istau, & E);
    VecGetSubVector( * X, user -> isni, & ni);
    VecScale(ni, 1e-20); // ni := tilde{ni} = (ni_0^-1) ni
    VecRestoreSubVector( * X, user -> isni, & ni);
    VecGetSubVector( * X, user -> isV, & Vi_perp);
    VecScale(Vi_perp, 1.0 / 11000000); // Vi_perp := tilde{Vi_perp} = (Vi_perp_0^-1) Vi_perp
    VecRestoreSubVector( * X, user -> isV, & Vi_perp);
  }

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return (0);
}

PetscErrorCode FormExactSolution_LargeData(PetscReal time, TS ts, Vec * X, void * ptr) {
  User * user = (User * ) ptr;
  DM da;
  PetscInt startr, startphi, startz, nr, nphi, nz;

  Vec xLocal;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];

  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];
  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  PetscScalar ** ** arrCoord, ** ** arrX, dt;
  PetscInt countz = 0, countphi = 0, countr = 0;

  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  for (d = 0; d < 3; ++d) {
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
  }
  /* Compute function over the locally owned part of the grid */
  DMGetLocalVector(da, & xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);
  TSGetTimeStep(ts, & dt);
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        if (user -> ictype == 1) {
          /* B(r, phi, z, t) = (cos(pi*t)/r) * ((z-0.5)^2 + sin(phi)) e_r */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrm[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrm[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrp[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrp[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = (cos(pi*t)*(2*z-1)/r) e_phi - (cos(pi*t)*cos(phi)/r^2) e_z */
          arrX[ez][ephi][er][ivErmzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzm[0]];
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzm[0]];
            arrX[ez][ephi][er][ivErpphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzp[0]];
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzp[0]];
          }
        }
        if (user -> ictype == 2) {
          /* B(r, phi, z, t) = sin(pi*r) exp(-t) e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphim[0]]) * PetscExpReal(-time);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphip[0]]) * PetscExpReal(-time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = (pi*cos(pi*r) + sin(pi*r)/r) exp(-t) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) / arrCoord[ez][ephi][er][icErmphim[0]]) * PetscExpReal(-time);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) / arrCoord[ez][ephi][er][icErpphim[0]]) * PetscExpReal(-time);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) / arrCoord[ez][ephi][er][icErmphip[0]]) * PetscExpReal(-time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) / arrCoord[ez][ephi][er][icErpphip[0]]) * PetscExpReal(-time);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 3) {
          /* B(r, phi, z, t) = cos(phi) e_r - sin(phi) e_phi */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(arrCoord[ez][ephi][er][icBrm[1]]);
          arrX[ez][ephi][er][ivBphim] = -PetscSinReal(arrCoord[ez][ephi][er][icBphim[1]]);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(arrCoord[ez][ephi][er][icBrp[1]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = -PetscSinReal(arrCoord[ez][ephi][er][icBphip[1]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 4) {
          /* B(r, phi, z, t) = e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 1.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 1.0;
          }
          /* E(r, phi, z, t) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 5) {
          /* B(r, phi, z, t) = (1/r) e_r */
          arrX[ez][ephi][er][ivBrm] = 1.0 / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 1.0 / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 6) {
          /* B(r, phi, z, t<=t_1) = (1 - t/r^2) e_phi */
          /* B(r, phi, z, t_1<t<=t_2) = (1 - 2dt/r^2 + time/r^2 - 3(time^2 - dt^2)/(2r^4) ) e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          /*arrX[ez][ephi][er][ivBphim] = 1.0 - time / PetscPowReal(arrCoord[ez][ephi][er][icBphim[0]],2) ;*/
          arrX[ez][ephi][er][ivBphim] = 1.0 - (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icBphim[0]], 2) - (time > 0.0) * 3.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icBphim[0]], 4));
          if (user -> debug) {
            PetscPrintf(PETSC_COMM_WORLD, "X_exact(Bphim) = %g\n", (double) arrX[ez][ephi][er][ivBphim]);
          }
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            /*arrX[ez][ephi][er][ivBphip] = 1.0 - time / PetscPowReal(arrCoord[ez][ephi][er][icBphip[0]],2) ;*/
            arrX[ez][ephi][er][ivBphip] = 1.0 - (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icBphip[0]], 2) - (time > 0.0) * 3.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icBphip[0]], 4));
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t<=t_1) = (1/r + t/r^3) e_z */
          /* E(r, phi, z, t<=t_2) = (1/r + 2dt/r^3 - time/r^3 + 9(time^2 - dt^2)/(2r^5) ) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          /*arrX[ez][ephi][er][ivErmphim] = 1.0 / arrCoord[ez][ephi][er][icErmphim[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErmphim[0]],3) ; */
          arrX[ez][ephi][er][ivErmphim] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErmphim[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErmphim[0]], 4))) / arrCoord[ez][ephi][er][icErmphim[0]];
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            /*arrX[ez][ephi][er][ivErpphim] = 1.0 / arrCoord[ez][ephi][er][icErpphim[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErpphim[0]],3);*/
            arrX[ez][ephi][er][ivErpphim] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErpphim[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErpphim[0]], 4))) / arrCoord[ez][ephi][er][icErpphim[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            /*arrX[ez][ephi][er][ivErmphip] = 1.0 / arrCoord[ez][ephi][er][icErmphip[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErmphip[0]],3);*/
            arrX[ez][ephi][er][ivErmphip] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErmphip[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErmphip[0]], 4))) / arrCoord[ez][ephi][er][icErmphip[0]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            /*arrX[ez][ephi][er][ivErpphip] = 1.0 / arrCoord[ez][ephi][er][icErpphip[0]] + time / PetscPowReal(arrCoord[ez][ephi][er][icErpphip[0]],3);*/
            arrX[ez][ephi][er][ivErpphip] = (1.0 + (time > 0.0) * (2.0 * dt - time) / PetscPowReal(arrCoord[ez][ephi][er][icErpphip[0]], 2) + (time > 0.0) * 9.0 * (PetscSqr(time) - PetscSqr(dt)) / (2.0 * PetscPowReal(arrCoord[ez][ephi][er][icErpphip[0]], 4))) / arrCoord[ez][ephi][er][icErpphip[0]];
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 7) {
          /* B(r, phi, z, t) = (cos(pi*t) + sin(phi)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) + PetscCosReal(PETSC_PI * time);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) + PetscCosReal(PETSC_PI * time);
          }
          /* E(r, phi, z, t) = (cos(phi)/r) e_r */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]) / arrCoord[ez][ephi][er][icEphimzm[0]];
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]) / arrCoord[ez][ephi][er][icEphipzm[0]];
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]) / arrCoord[ez][ephi][er][icEphimzp[0]];
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]) / arrCoord[ez][ephi][er][icEphipzp[0]];
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        }
        if (user -> ictype == 8) {
          /* B(r, phi, z, t) = exp(sin(phi)*r+t) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) * arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) * arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* E(r, phi, z, t) = exp(sin(phi)*r+t) * (cos(phi) e_r - sin(phi) e_phi) */
          arrX[ez][ephi][er][ivErmzm] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]) * arrCoord[ez][ephi][er][icErmzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]);
          arrX[ez][ephi][er][ivEphimzm] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphimzm[1]]) * arrCoord[ez][ephi][er][icEphimzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]);
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]) * arrCoord[ez][ephi][er][icErpzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]);
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphipzm[1]]) * arrCoord[ez][ephi][er][icEphipzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]);
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]) * arrCoord[ez][ephi][er][icErmzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]);
            arrX[ez][ephi][er][ivEphimzp] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphimzp[1]]) * arrCoord[ez][ephi][er][icEphimzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]);
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icEphipzp[1]]) * arrCoord[ez][ephi][er][icEphipzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]);
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = -PetscExpReal(time + PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]) * arrCoord[ez][ephi][er][icErpzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]);
          }
        }

        if (user -> ictype == 9) {
          char filename[PETSC_MAX_PATH_LEN];
          /* B(r, phi, z, t=0) Loaded from ReadInitialData output */
          PetscSNPrintf(filename, PETSC_MAX_PATH_LEN, "%s/vecBr.txt", user->input_folder);
          ReadALine(filename, er + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1), & arrX[ez][ephi][er][ivBrm] );
          arrX[ez][ephi][er][ivBrm] /= user->B0;
          if (er == N[0] - 1) {
            ReadALine(filename, er + 1 + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1), & arrX[ez][ephi][er][ivBrp] );
            arrX[ez][ephi][er][ivBrp] /= user->B0;
          }

          PetscSNPrintf(filename, PETSC_MAX_PATH_LEN, "%s/vecBphi.txt", user->input_folder);
          ReadALine(filename, er + ephi * N[0] + ez * N[0] * (N[1] + 1), & arrX[ez][ephi][er][ivBphim] );
          arrX[ez][ephi][er][ivBphim] /= user->B0;
          if (ephi == N[1] - 1) {
            ReadALine(filename, er + (ephi + 1) * N[0] + ez * N[0] * (N[1] + 1), & arrX[ez][ephi][er][ivBphip] );
            arrX[ez][ephi][er][ivBphip] /= user->B0;
          }

          PetscSNPrintf(filename, PETSC_MAX_PATH_LEN, "%s/vecBz.txt", user->input_folder);
          ReadALine(filename, er + ephi * N[0] + ez * N[0] * N[1], & arrX[ez][ephi][er][ivBzm] );
          arrX[ez][ephi][er][ivBzm] /= user->B0;
          if (ez == N[2] - 1) {
            ReadALine(filename, er + ephi * N[0] + (ez + 1) * N[0] * N[1], & arrX[ez][ephi][er][ivBzp] );
            arrX[ez][ephi][er][ivBzp] *= 0.2;
          }

          /* tau(r, phi, z, t=0) initialized with zero values. The E field will be computed later from B field with the derived curl operator */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 10) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 1.0;
          arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) initialized with zero values. The tau field can be computed later from B field with the derived curl operator */
          /*arrX[ez][ephi][er][ivErmzm] = 0.0;
            arrX[ez][ephi][er][ivEphimzm] = 0.0;
            arrX[ez][ephi][er][ivErmphim] = 0.0;
            if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
            }
            if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
            }
            if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
            }
            if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
            }
            if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
            }
            if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
            }*/
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 11) {
          /* B(r, phi, z, t=0) = [2+cos(eta/mu0 * t)] * [e_phi + sqrt(2*ln(2*r_max/r)) e_z] */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          arrX[ez][ephi][er][ivBzm] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) * (cos(eta/mu0 * t) + 2)/r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          if(er == 0 || ez == 0){
            arrX[ez][ephi][er][ivErmzm] = 0.0;
          }
          else{
            arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, BACK_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          }
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          if((ephi == 0 && !user->phibtype) || er == 0){
            arrX[ez][ephi][er][ivErmphim] = 0.0;
          }
          else{
            arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, DOWN_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          }
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, UP_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 12) {
          /* B(r, phi, z, t=0) = exp(- z / z_max) / r e_r + (r - z) e_phi + cos(2*r_max/r) e_z */
          arrX[ez][ephi][er][ivBrm] = PetscExpReal(- arrCoord[ez][ephi][er][icBrm[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = arrCoord[ez][ephi][er][icBphim[0]] - arrCoord[ez][ephi][er][icBphim[2]];
          arrX[ez][ephi][er][ivBzm] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscExpReal(- arrCoord[ez][ephi][er][icBrp[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = arrCoord[ez][ephi][er][icBphip[0]] - arrCoord[ez][ephi][er][icBphip[2]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        if (user -> ictype == 13) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          if(er!=0) {
            arrX[ez][ephi][er][ivBrm] = 0.0;
          }
          arrX[ez][ephi][er][ivBphim] = 1.0;
          if(ez!=0) {
            arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          }
          if(er==0) {
            arrX[ez][ephi][er][ivBrm] = NAN;
          }
          if(ez==0) {
            arrX[ez][ephi][er][ivBzm] = NAN;
          }
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = NAN;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = NAN;
          }
          /* tau(r, phi, z, t=0) = 0 */
          /*
             arrX[ez][ephi][er][ivErmzm] = 0.0;
             arrX[ez][ephi][er][ivEphimzm] = 0.0;
             arrX[ez][ephi][er][ivErmphim] = 0.0;
             if (er == N[0] - 1) {
             arrX[ez][ephi][er][ivErpzm] = 0.0;
             arrX[ez][ephi][er][ivErpphim] = 0.0;
             }
             if (ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivEphipzm] = 0.0;
             arrX[ez][ephi][er][ivErmphip] = 0.0;
             }
             if (ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErmzp] = 0.0;
             arrX[ez][ephi][er][ivEphimzp] = 0.0;
             }
             if (er == N[0] - 1 && ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivErpphip] = 0.0;
             }
             if (ephi == N[1] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivEphipzp] = 0.0;
             }
             if (er == N[0] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErpzp] = 0.0;
             }*/

          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }
      }
    }
  }
  /* Restore vectors */
  DMStagVecRestoreArray(da, xLocal, & arrX);
  DMLocalToGlobal(da, xLocal, INSERT_VALUES, * X);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);

  if (user -> ictype == 9 && user -> Ebc) {
    Vec Xcopy;
    VecDuplicate( * X, & Xcopy);
    VecCopy( * X, Xcopy);
    VecScale(Xcopy, 1.0 / 11000000.0);
    FormDerivedCurl(ts, Xcopy, * X, user); //This updates only the E field part in X by computing the derived mimetic curl operator applied to B field of Xcopy
                                           //PetscBarrier((PetscObject) Xcopy);
    VecDestroy( & Xcopy);
  }

  if (0) {
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       Normalize the system
       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    Vec B, E, ni, Vi_perp;
    VecGetSubVector( * X, user -> isB, & B);
    VecScale(B, 0.2); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( * X, user -> isB, & B);
    VecGetSubVector( * X, user -> istau, & E);
    VecScale(E, 0.2); // E := tilde{E} = (E_0^-1) E
    VecScale(E, 1.0 / 11000000); // E := tilde{E} = (E_0^-1) E
    VecRestoreSubVector( * X, user -> istau, & E);
    VecGetSubVector( * X, user -> isni, & ni);
    VecScale(ni, 1e-20); // ni := tilde{ni} = (ni_0^-1) ni
    VecRestoreSubVector( * X, user -> isni, & ni);
    VecGetSubVector( * X, user -> isV, & Vi_perp);
    VecScale(Vi_perp, 1.0 / 11000000); // Vi_perp := tilde{Vi_perp} = (Vi_perp_0^-1) Vi_perp
    VecRestoreSubVector( * X, user -> isV, & Vi_perp);
  }

  return (0);
}

PetscErrorCode Update_J_RE(TS ts)
{

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("Update_J_RE",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);


  PetscPrintf(PETSC_COMM_WORLD, "Update_J_RE");

  User          *user;
  Vec X, postprocB, curl, postprocX, B, div, div2;
  Mat D;
  PetscReal dt, time, normmax, norm2;
  PetscInt step, nr,  nphi, nz, count;
  DM da;
  TS dummyts;

  TSGetDM(ts, & da);
  DMGetApplicationContext(da, &user);

  if (user -> delay_kinetic > 0)
  {
    PetscPrintf(PETSC_COMM_WORLD, "Skipping kinetic phase");
    -- user->delay_kinetic;
    return (0);

  }
  user->CorrectorIdentifier = 1;
  TSGetTimeStep(ts, & dt);
  TSGetTime(ts, & time);
  TSGetStepNumber(ts, &step);
  TSGetSolution(ts, &X);

  // Duplicate X in X_star, first particle push is on constant fields
  VecCopy(X, user->X_star);
  PetscPrintf(PETSC_COMM_WORLD, "user dt = %g", (double) user->dt);
  PetscPrintf(PETSC_COMM_WORLD, "Pushing particles with (B_n,E_n) at time %g, count =%d\n", (double) time, count);
  PushParticles(ts, X, user->X_star, user);
  PetscPrintf(PETSC_COMM_WORLD, "Finish particles with (B_n,E_n)\n");

  for (count = 0; count < user->pred_loop; count++) {
    runaway_restoreState(user->manager);

    SNES dummysnes;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);

    TSGetSNES(dummyts, & dummysnes);
    TSSetType(ts, TSBEULER); /* Backward Euler method */

    DMCreateMatrix(da, & J);

    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_Vperp_viscosity, user);
    TSSetRHSFunction(dummyts, NULL, FormRHSFunction_BImplicit, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    TSSetTime(dummyts, time);
    TSSetMaxSteps(dummyts, 1);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 1.0*dt);
    TSSetSolution(dummyts, user->X_star);

    //TSSetFromOptions(dummyts);
    if(user -> adaptdt){
      // Adaptive Time Step Controller
      TSAdapt adapt;
      TSGetAdapt(dummyts,&adapt);
      TSAdaptSetScaleSolveFailed(adapt, 0.5);
      adapt->ops->choose = TSAdaptChoose_user;
      TSAdaptSetMonitor( adapt, PETSC_TRUE);
      TSSetMaxSNESFailures( dummyts, -1);
    }
    TSSetUp(dummyts);

    SNESGetKSP(dummysnes, & dummyKSP);
    //TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);

    PCSetType(dummypc,PCBJACOBI);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    PetscBool is_fieldsplit;
    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;


        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_EP[1], stencil_noe_notEP[6];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EP", "BV"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is 4th dofs on vertices
          stencil_noe_EP[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_EP[0].c = 3;

          // Second split within notv is faces and the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_notEP[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_notEP[c].c = c;
          }
          stencil_noe_notEP[3].loc = DMSTAG_LEFT;
          stencil_noe_notEP[3].c = 0;
          stencil_noe_notEP[4].loc = DMSTAG_BACK;
          stencil_noe_notEP[4].c = 0;
          stencil_noe_notEP[5].loc = DMSTAG_DOWN;
          stencil_noe_notEP[5].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_noe,1,stencil_noe_EP,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,6,stencil_noe_notEP,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      PC            pc_noe_2;

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"B", "V"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,3,0,1,0,&dm_notv));

          // First split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          // Second split within notv is vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notv_notfaces[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notv_notfaces[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_notfaces,&is_notv[1]));


          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-5,PETSC_DEFAULT,PETSC_DEFAULT,300);

    TSSolve(dummyts, user->X_star);
    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "PRESTEP => Computing (B_star,E_star): %s at time %g after %d steps, count =%d\n", TSConvergedReasons[reason], (double) ftime, steps, count);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);

    {
      Vec diffX;
      PetscReal norm_2, norm_max;
      VecDuplicate(X, & diffX);
      VecZeroEntries(diffX);
      VecWAXPY(diffX, -1.0, user -> X_star, X);
      VecNorm(diffX, NORM_2, & norm_2);
      VecNorm(diffX, NORM_MAX, & norm_max);
      TSGetTimeStep(dummyts, & dt);
      PetscPrintf(PETSC_COMM_WORLD, "Timestep %3D (PREDICTOR): step size = %g, time = %g, 2-norm of X^{n} - X^{n+1,*} = %g, max norm of X^{n} - X^{n+1,*} = %g  , count =%d\n", (int)(step + user -> oldstep), (double) dt, (double) time, (double) norm_2, (double) norm_max, count);
      VecDestroy(& diffX);
    }

    TSDestroy( & dummyts);
   // RuKS_reset(user->runaway_solver);
    PetscPrintf(PETSC_COMM_WORLD, "(B_{n},E_{n})*(t_{n+1} - t)+ (B_{n+1,\ast},E_{n+1,\ast})*(t-t_n)/dt at time %g, count =%d \n", (double) ftime, count);
    PushParticles(ts, X, user->X_star, user);
    PetscPrintf(PETSC_COMM_WORLD, "(B_{n},E_{n})*(t_{n+1} - t)+ (B_{n+1,\ast},E_{n+1,\ast})*(t-t_n)/dt finish \n", (double) ftime, count);
    /* user->present_current = RuKS_getIre(user->runaway_solver); */
  }
  runaway_saveState(user->manager);
  return 0;
}

PetscErrorCode Monitor(TS ts, PetscInt step, PetscReal time, Vec X, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("Monitor",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  Mat D;
  Vec exactX, div, div2, curl, postprocX, B;
  PetscReal norm2, normmax, dt;
  PetscInt nr, nphi, nz;
  DM da, newda;
  PetscScalar Iphi1, Iphi2;

  TSGetTimeStep(ts, & dt);
  /* Adjust the viscosity coefficient and step size over time*/
  //TSSetTimeStep(ts,2*dt);
  //user->Re = 1.0 * PetscExpReal(4*(time + dt - user->itime)/10.0);
  //user->Re = 1.0 + (9.0/20.0) * (time + dt - user->itime);
  //user->Re = 1.0/(0.001 + 0.999 * PetscExpReal(-(time + dt - user->itime)/0.53));
  //user->Re = 1.0/(0.1 + 0.9 * PetscExpReal(-(time + dt - user->itime)/10.0));
  //if(step>100){
  //TSSetTimeStep(ts,200.0);
  //}
  //else{
  //TSSetTimeStep(ts,user->Re/5.0);
  //}
  //user->Re = 1.0/(0.01 + 0.09 * PetscExpReal(-(time + dt - user->itime)/100.0));

  // diffX := X - oldX = X^{n+1} - X^{n} for the corrector
  {
    Vec diffX;
    PetscReal norm_2, norm_max;
    VecDuplicate(X, & diffX);
    VecZeroEntries(diffX);
    VecWAXPY(diffX, -1.0, user -> oldX, X);
    VecNorm(diffX, NORM_2, & norm_2);
    VecNorm(diffX, NORM_MAX, & norm_max);
    PetscPrintf(PETSC_COMM_WORLD, "Timestep %3D (CORRECTOR): step size = %g, time = %g, 2-norm of X^{n+1} - X^{n} = %g, max norm of X^{n+1} - X^{n} = %g\n", (int)(step + user -> oldstep), (double) dt, (double) time, (double) norm_2, (double) norm_max);
    VecDestroy(& diffX);
  }
  /* Compute the exact solution */
  TSGetDM(ts, & da);
  if (user -> ictype != 9){
    DMCreateGlobalVector(da, & exactX);
    FormExactSolution(time, ts, & exactX, user);
  }

  /* Save intermediate and final solutions in .dat files */
  if (user -> tempdump) {
    if ((time >= user -> ftime) || (step > 0 && (step % user -> dumpfreq == 0)))
    {
      PetscPrintf(PETSC_COMM_WORLD, "Saving intermediate solution at time %g, step %d\n", (double) time, step);
      SaveIntermediateSolution(ts, (int)(step + user -> oldstep), time, X, user);
      char filename[PETSC_MAX_PATH_LEN];
      snprintf(filename, 50, "./snapshot_%d.h5", (int)(step + user -> oldstep));
      /* RuKS_H5Write(user->runaway_solver, filename); */
    }
  }
  //if (user->step_gl > -1) PushParticles(ts, user->oldX, X, user, 0);
  //user->step_gl++;
  /* Save solution in .vtr files */
  // PetscPrintf(PETSC_COMM_WORLD,"About to check for dump, dump = %g", (int) user -> dump);

  if (user -> dump) {
    // PetscPrintf(PETSC_COMM_WORLD,"dump flag checked");

    DumpSolution_Cell(ts, (int)(step + user -> oldstep), X, user);
    Computepsi(ts, (int)(step + user -> oldstep), X, user);
    if (1 && user -> ictype == 9 && user -> oldstep == 0) {
      DumpLevelSet(ts, user);
    }
  }

  if (user -> dump && 0) {
    /* Save the vector laplacian of V */
    Vec LapV;
    VecDuplicate(X, & LapV);
    VecZeroEntries(LapV);
    ApplyVectorLaplacian(ts, X, LapV, user);
    VecScale(LapV, (1.0 / user->Re));
    char prefix[2];  //allocate memory
    sprintf(prefix, "lv");
    DumpVelocity_Cell(ts, (int)(step + user -> oldstep), LapV, prefix, user);

    if (step != 0) {
      VecCopy(X, LapV); /* LapV := X */
      VecAXPBY(LapV, -10.0, 10.0, user -> oldX); /* LapV := - (1/dt) oldX + (1/dt) LapV */
      sprintf(prefix, "dv");
      DumpVelocity_Cell(ts, (int)(step + user -> oldstep), LapV, prefix, user);
    }

    VecDestroy( & LapV);
  }
  /* Save SNES residual */
  if(0){
    SNES snes;
    TSGetSNES(ts, & snes);
    Vec residual;
    VecDuplicate(X,&residual);

    Vec Xdot;
    VecDuplicate(X,&Xdot);
    VecZeroEntries(Xdot);
    FormIFunction_Vperp_viscosity(ts, time, X, Xdot, residual, user);
    VecDestroy( & Xdot);

    //SNESGetFunction(snes, & residual, NULL, NULL);
    DumpSolution_Cell(ts, (int)(step + 800), residual, user);
    //VecDestroy( & residual);
  }
  /* Save curl(B)xB and curl(B) */
  if(0){
    Vec Bv, curlBv, CurlBxB;
    /* P_{f->v}(B) */
    DMCreateGlobalVector(da, & Bv);
    FaceToVertexProjection(ts, X, Bv, user);
    /* P_{e->v}(der_curl_no_mp(B)) */
    DMCreateGlobalVector(da, & curlBv);
    VecZeroEntries(curlBv);
    Vec curlB;
    VecDuplicate(X, & curlB);
    VecCopy(X, curlB);
    FormDerivedCurlnomp(ts, X, curlB, user); //This updates only the E field part in curlB by computing the derived mimetic curl operator applied to B field of X that does not include material properties
    DumpEdgeField(ts, (int)(step + user -> oldstep), curlB, user);
    EdgeToVertexProjection(ts, curlB, curlBv, user);
    //PetscBarrier((PetscObject) curlB);
    VecDestroy( & curlB);
    /* VxP_{f->v}(B) */
    DMCreateGlobalVector(da, & CurlBxB);
    VecZeroEntries(CurlBxB);
    VertexCrossProduct(ts, curlBv, Bv, CurlBxB, user);
    //Dump1stVertexField(ts, (int)(step + user -> oldstep), CurlBxB, user);
    //PetscBarrier((PetscObject) CurlBxB);
    VecDestroy( & Bv);
    VecDestroy( & curlBv);
    VecDestroy( & CurlBxB);
  }
  /* Save curl(tau) */
  if(0){
    Vec curltau;
    VecDuplicate(X, & curltau);
    VecCopy(X, curltau);
    FormPrimaryCurl(ts, X, curltau, user); //This updates only the B field part in curltau by computing the primary mimetic curl operator applied to tau field of X
    DumpSolution_Cell(ts, (int)(step + user -> oldstep + 100), curltau, user);
    VecDestroy( & curltau);
  }

  /* Compute the 2-norm and max-norm of the error */
  if (user -> ictype != 9){
    VecAXPY(exactX, -1.0, X);
    VecNorm(exactX, NORM_2, & norm2);
    /* norm_2 = PetscSqrtReal(appctx->h)*norm_2; Scale the 2-norm by the grid spacing */
    norm2 = norm2 * PetscSqrtReal(user -> dr * user -> dphi * user -> dz); /* Scale the 2-norm by the grid spacing */
    VecNorm(exactX, NORM_MAX, & normmax);
  }
  /* Save Error in .vtr files */
  if (user -> dump && user -> ictype != 9 && user -> ictype != 10) {
    DumpError(ts, (int)(step + user -> oldstep), exactX, user);
  }
  /* Display information at each time step */
  if (user -> ictype != 9 && user -> ictype != 10) PetscPrintf(PETSC_COMM_WORLD, "Timestep %3D: step size = %g, time = %g, 2-norm error = %g, max norm error = %g\n", (int)(step + user -> oldstep), (double) dt, (double) time, (double) norm2, (double) normmax);

  /* Print debugging information if desired */
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "Error vector\n");
    VecView(exactX, PETSC_VIEWER_STDOUT_WORLD);
  }

  /* Back substitution : B^{n+1} := B^{n} - dt * primary_curl(E^{n+1}) */
  DMCreateGlobalVector(da, & curl);
  DMCreateGlobalVector(da, & postprocX);

  if (step != 0) {
    FormPrimaryCurl(ts, X, curl, user);
    VecAXPBYPCZ(postprocX, 1.0, -user -> dt, 0.0, user -> oldX, curl); /* postprocX = oldX - dt * curl */
  }
  VecCopy(X, user -> oldX);


  /* Check that the solution is divergence-free */
  /* Create a new DM to store cell-centered divergence values */
  DMStagGetNumRanks(da, & nr, & nphi, & nz);
  if (user -> phibtype) {
    DMStagCreate3d(PETSC_COMM_WORLD, DM_BOUNDARY_NONE, DM_BOUNDARY_PERIODIC, DM_BOUNDARY_NONE, user -> Nr, user -> Nphi, user -> Nz, nr, nphi, nz, 0, 0, 0, 1, DMSTAG_STENCIL_BOX, 1, NULL, NULL, NULL, & newda);
  } else {
    DMStagCreate3d(PETSC_COMM_WORLD, DM_BOUNDARY_NONE, DM_BOUNDARY_NONE, DM_BOUNDARY_NONE, user -> Nr, user -> Nphi, user -> Nz, nr, nphi, nz, 0, 0, 0, 1, DMSTAG_STENCIL_BOX, 1, NULL, NULL, NULL, & newda);
  }
  DMSetFromOptions(newda);
  DMSetUp(newda);
  DMStagSetUniformCoordinatesExplicit(newda, user->rmin/user->L0, user->rmax/user->L0, user->phimin, user->phimax, user->zmin/user->L0, user->zmax/user->L0);

  DMCreateGlobalVector(newda, & div);
  DMCreateMatrix(user -> coorda, & D);
  FormDiscreteDivergence(ts, newda, D, X, div, user);
  VecScale(div, 1.0/user->L0);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "Divergence operator matrix: \n");
    MatView(D, PETSC_VIEWER_STDOUT_WORLD);

    /* MatMult(D,X,Y); */
    PetscPrintf(PETSC_COMM_WORLD, "X vector: \n");
    VecView(X, PETSC_VIEWER_STDOUT_WORLD);

    /* PetscPrintf(PETSC_COMM_WORLD,"Divergence of B vector: \n");
       VecView(Y,PETSC_VIEWER_STDOUT_WORLD); */

    PetscPrintf(PETSC_COMM_WORLD, "Divergence of B vector: \n");
    VecView(div, PETSC_VIEWER_STDOUT_WORLD);
  }
  VecNorm(div, NORM_MAX, & normmax);
  if (user -> ictype != 9 && user -> ictype != 10){
    PetscPrintf(PETSC_COMM_WORLD, "max norm error of divergence of B = %g\n", (double) normmax);

  }
  else {
    PetscPrintf(PETSC_COMM_WORLD, "Timestep %3D: step size = %g, time = %g, max norm error of divergence of B = %g\n", (int)(step + user -> oldstep), (double) dt, (double) time, (double) normmax);
  }

  if (user -> dump) {
    DumpDivergence(ts, newda, (int)(step + user -> oldstep), div, user);
  }

  if (user -> tstype > 1) {
    VecGetSubVector(X, user -> isB, & B);
    VecNorm(B, NORM_MAX, & norm2);
    PetscPrintf(PETSC_COMM_WORLD, "max_norm(div B) / max_norm(B) = %g\n", (double) normmax / norm2);
    VecRestoreSubVector(X, user -> isB, & B);
  }

  /* Check that the post-processed solution is divergence-free */
  DMCreateGlobalVector(newda, & div2);
  if (step != 0) {
    FormDiscreteDivergence(ts, newda, D, postprocX, div2, user);
    VecNorm(div2, NORM_MAX, & normmax);
    PetscPrintf(PETSC_COMM_WORLD, "max norm error of divergence of post-processed B = %g\n", (double) normmax);
    if (user -> tstype > 1) {
      VecGetSubVector(postprocX, user -> isB, & B);
      VecNorm(B, NORM_MAX, & norm2);
      PetscPrintf(PETSC_COMM_WORLD, "max_norm(div postprocB) / max_norm(postprocB) = %g\n", (double) normmax / norm2);
      VecRestoreSubVector(postprocX, user -> isB, & B);
    }
  }

  ComputeCurrent(ts, X, user);
  PetscPrintf(PETSC_COMM_WORLD, "Current intensity inside plasma = %g\n", (double)(user -> Iphi1));
  PetscPrintf(PETSC_COMM_WORLD, "Current intensity outside plasma = %g\n", (double)(user -> Iphi2));
  PetscPrintf(PETSC_COMM_WORLD, "Current intensity inside vacuum vessel = %g\n", (double)(user -> Iphi3));

  FILE *fp;
  fp = fopen("TotalCurrent.txt", "a");
  PetscFPrintf(PETSC_COMM_WORLD, fp, " %.8f  %.8f \n", (double) time, (double) (user -> Iphi1) );
  fclose(fp);

  /* DESTROY VECTORS */
  if (user -> ictype != 9){
    VecDestroy( & exactX);
  }
  MatDestroy( & D);
  VecDestroy( & div);
  VecDestroy( & div2);
  VecDestroy( & curl);
  VecDestroy( & postprocX);
  DMDestroy( & newda);

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return 0;
}

PetscErrorCode FormDummyIJacobian(TS ts, PetscReal t, Vec X, Vec Xdot, PetscReal a, Mat J, Mat Jpre, void * ptr) {
  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscInt N[3], er, ephi, ez, d;

  MatZeroEntries(Jpre);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);

  /* Loop over all local elements */
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        DMStagStencil row, col[5];
        PetscScalar valJ[5];
        PetscInt nEntries;

        /* The edges are oriented in the directions of unit vectors: e_r, e_phi and e_z */

        /* B Field part */

        /*if (!(er == 0)){*/
        /* Equation on left face */
        nEntries = 1;
        row.i = er;
        row.j = ephi;
        row.k = ez;
        row.loc = LEFT;
        row.c = 0;

        col[0].i = er;
        col[0].j = ephi;
        col[0].k = ez;
        col[0].loc = LEFT;
        col[0].c = 0;
        valJ[0] = a;

        DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        /*}*/

        /*if(user->phibtype || (ephi != 0 && !(user->phibtype)) ){*/
        /* Equation on down face */
        nEntries = 1;
        row.i = er;
        row.j = ephi;
        row.k = ez;
        row.loc = DOWN;
        row.c = 0;

        col[0].i = er;
        col[0].j = ephi;
        col[0].k = ez;
        col[0].loc = DOWN;
        col[0].c = 0;
        valJ[0] = a;

        DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        /*}*/

        /*if (!(ez == 0)){*/
        /* Equation on back face */
        nEntries = 1;
        row.i = er;
        row.j = ephi;
        row.k = ez;
        row.loc = BACK;
        row.c = 0;

        col[0].i = er;
        col[0].j = ephi;
        col[0].k = ez;
        col[0].loc = BACK;
        col[0].c = 0;
        valJ[0] = a;

        DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        /*}*/

        if (er == N[0] - 1) {
          /* Equation on right boundary face */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = RIGHT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = RIGHT;
          col[0].c = 0;
          valJ[0] = a;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          /* Equation on up boundary face */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = UP;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = UP;
          col[0].c = 0;
          valJ[0] = a;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (ez == N[2] - 1) {
          /* Equation on front boundary face */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT;
          col[0].c = 0;
          valJ[0] = a;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

      }
    }
  }

  MatAssemblyBegin(Jpre, MAT_FINAL_ASSEMBLY);
  MatAssemblyEnd(Jpre, MAT_FINAL_ASSEMBLY);

  if (J != Jpre) {
    MatAssemblyBegin(J, MAT_FINAL_ASSEMBLY);
    MatAssemblyEnd(J, MAT_FINAL_ASSEMBLY);
  }
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "Jpre:\n");
    MatView(Jpre, PETSC_VIEWER_STDOUT_WORLD);
  }
  return (0);
}

PetscErrorCode FormDummyIJacobian2(TS ts, PetscReal t, Vec X, Vec Xdot, PetscReal a, Mat J, Mat Jpre, void * ptr) {
  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscInt N[3], er, ephi, ez, d;

  MatZeroEntries(Jpre);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);

  /* Loop over all local elements */
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        DMStagStencil row, col[5];
        PetscScalar valJ[5];
        PetscInt nEntries;

        /* The edges are oriented in the directions of unit vectors: e_r, e_phi and e_z */

        /* E field part */

        if (er == 0 || ez == 0) {
          /* Equation on the back or left boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_LEFT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_LEFT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if ((user -> phibtype && (er == 0)) || (((er == 0 || ephi == 0)) && !(user -> phibtype))) {
          /* Equation on the left or down boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = DOWN_LEFT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = DOWN_LEFT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if ((user -> phibtype && (ez == 0)) || (((ephi == 0 || ez == 0)) && !(user -> phibtype))) {
          /* Equation on the left or down boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_DOWN;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_DOWN;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (er == N[0] - 1) {
          /* Equation on the right boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_RIGHT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_RIGHT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);

          /* Equation on the right boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = DOWN_RIGHT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = DOWN_RIGHT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          /* Equation on the up boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_UP;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_UP;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);

          /* Equation on the up boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = UP_LEFT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = UP_LEFT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (ez == N[2] - 1) {
          /* Equation on the front boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_LEFT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_LEFT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);

          /* Equation on the front boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_DOWN;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_DOWN;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          /* Equation on the right and up boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = UP_RIGHT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = UP_RIGHT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (ephi == N[1] - 1 && ez == N[2] - 1 && !(user -> phibtype)) {
          /* Equation on the right and up boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_UP;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_UP;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (er == N[0] - 1 && ez == N[2] - 1) {
          /* Equation on the front and right boundary */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_RIGHT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_RIGHT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if ((user -> phibtype && !(er == 0)) || ((!(er == 0 || ephi == 0)) && !(user -> phibtype))) {
          /* Equation on internal down left edge */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = DOWN_LEFT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = DOWN_LEFT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if ((user -> phibtype && !(ez == 0)) || ((!(ez == 0 || ephi == 0)) && !(user -> phibtype))) {
          /* Equation on internal back down edge */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_DOWN;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_DOWN;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

        if (!(er == 0 || ez == 0)) {
          /* Equation on internal back left edge */
          nEntries = 1;
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_LEFT;
          row.c = 0;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_LEFT;
          col[0].c = 0;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }

      }
    }
  }

  MatAssemblyBegin(Jpre, MAT_FINAL_ASSEMBLY);
  MatAssemblyEnd(Jpre, MAT_FINAL_ASSEMBLY);

  if (J != Jpre) {
    MatAssemblyBegin(J, MAT_FINAL_ASSEMBLY);
    MatAssemblyEnd(J, MAT_FINAL_ASSEMBLY);
  }
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "Jpre:\n");
    MatView(Jpre, PETSC_VIEWER_STDOUT_WORLD);
  }
  return (0);
}

PetscErrorCode FormDummyIJacobian3(TS ts, PetscReal t, Vec X, Vec Xdot, PetscReal a, Mat J, Mat Jpre, void * ptr) {
  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscInt N[3], er, ephi, ez, d;

  MatZeroEntries(Jpre);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);

  /* Loop over all local elements */
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        DMStagStencil row, col[1];
        PetscScalar valJ[1];
        PetscInt nEntries = 1;

        /* density field part: n_i */

        nEntries = 1;
        row.i = er;
        row.j = ephi;
        row.k = ez;
        row.loc = ELEMENT;
        row.c = 0;

        col[0].i = er;
        col[0].j = ephi;
        col[0].k = ez;
        col[0].loc = ELEMENT;
        col[0].c = 0;
        valJ[0] = 1.0;

        DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
      }
    }
  }

  MatAssemblyBegin(Jpre, MAT_FINAL_ASSEMBLY);
  MatAssemblyEnd(Jpre, MAT_FINAL_ASSEMBLY);

  if (J != Jpre) {
    MatAssemblyBegin(J, MAT_FINAL_ASSEMBLY);
    MatAssemblyEnd(J, MAT_FINAL_ASSEMBLY);
  }
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "Jpre:\n");
    MatView(Jpre, PETSC_VIEWER_STDOUT_WORLD);
  }
  return (0);
}

PetscErrorCode FormDummyIJacobian4(TS ts, PetscReal t, Vec X, Vec Xdot, PetscReal a, Mat J, Mat Jpre, void * ptr) {
  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscInt N[3], er, ephi, ez, d;

  MatZeroEntries(Jpre);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);

  /* Loop over all local elements */
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        DMStagStencil row, col[1];
        PetscScalar valJ[1];
        PetscInt nEntries = 1;

        /* Electrostatic potential part: Phi */

        nEntries = 1;
        row.i = er;
        row.j = ephi;
        row.k = ez;
        row.loc = BACK_DOWN_LEFT;
        row.c = 3;

        col[0].i = er;
        col[0].j = ephi;
        col[0].k = ez;
        col[0].loc = BACK_DOWN_LEFT;
        col[0].c = 3;
        valJ[0] = 1.0;

        DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);

        if (er == N[0] - 1) {
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_DOWN_RIGHT;
          row.c = 3;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_DOWN_RIGHT;
          col[0].c = 3;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }
        if (ephi == N[1] - 1 && !user -> phibtype) {
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_UP_LEFT;
          row.c = 3;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_UP_LEFT;
          col[0].c = 3;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }
        if (ez == N[2] - 1) {
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_DOWN_LEFT;
          row.c = 3;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_DOWN_LEFT;
          col[0].c = 3;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !user -> phibtype) {
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = BACK_UP_RIGHT;
          row.c = 3;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = BACK_UP_RIGHT;
          col[0].c = 3;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !user -> phibtype) {
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_UP_LEFT;
          row.c = 3;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_UP_LEFT;
          col[0].c = 3;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_DOWN_RIGHT;
          row.c = 3;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_DOWN_RIGHT;
          col[0].c = 3;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !user -> phibtype) {
          row.i = er;
          row.j = ephi;
          row.k = ez;
          row.loc = FRONT_UP_RIGHT;
          row.c = 3;

          col[0].i = er;
          col[0].j = ephi;
          col[0].k = ez;
          col[0].loc = FRONT_UP_RIGHT;
          col[0].c = 3;
          valJ[0] = 1.0;

          DMStagMatSetValuesStencil(da, Jpre, 1, & row, nEntries, col, valJ, INSERT_VALUES);
        }
      }
    }
  }

  MatAssemblyBegin(Jpre, MAT_FINAL_ASSEMBLY);
  MatAssemblyEnd(Jpre, MAT_FINAL_ASSEMBLY);

  if (J != Jpre) {
    MatAssemblyBegin(J, MAT_FINAL_ASSEMBLY);
    MatAssemblyEnd(J, MAT_FINAL_ASSEMBLY);
  }
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "Jpre:\n");
    MatView(Jpre, PETSC_VIEWER_STDOUT_WORLD);
  }
  return (0);
}

PetscErrorCode SampleShellPCSetUp(PC pc){
  User * user;
  SNES snes;
  Mat J;
  KSP KSP_ETBN;
  PC PC_ETBN, PC_V, PC_B, PC_EP;
  PetscErrorCode ierr = 0;

  PCShellGetContext(pc,&user);
  Mat myS;

  /* Creating matrices */
  ierr = MatCreate(PETSC_COMM_WORLD,&myS); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->DiagBlock_V); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->OffDiagBlock_L); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->OffDiagBlock_U); CHKERRQ(ierr);

  const IS islist2[5] = {user->isV, user->isEP, user->istau, user->isB, user->isni};
  IS isALL;

  ierr = ISConcatenate(PETSC_COMM_WORLD,5,islist2,&isALL); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields are as follows.\n");
  //ISView(isALL,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = ISDifference(isALL, user->isV, & user->isALL_V); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields except V are as follows.\n");
  //ISView(isALL_V,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = TSGetSNES(user->ts, & snes); CHKERRQ(ierr);
  SNESGetJacobian(snes,&J,NULL,NULL,NULL);

  ierr = MatGetSchurComplement (J, user->isALL_V, user->isALL_V, user->isV, user->isV, MAT_INITIAL_MATRIX, & user->DiagBlock_V, MAT_SCHUR_COMPLEMENT_AINV_DIAG, MAT_INITIAL_MATRIX, &myS); CHKERRQ(ierr);

  ierr = MatDestroy(&myS); CHKERRQ(ierr);
  ierr = ISDestroy( & isALL); CHKERRQ(ierr);

  MatCreateSubMatrix(J,user->isALL_V,user->isV,MAT_INITIAL_MATRIX,& user->OffDiagBlock_U);
  MatCreateSubMatrix(J,user->isV,user->isALL_V,MAT_INITIAL_MATRIX,& user->OffDiagBlock_L);

  /* Creating and setting KSP Solvers*/
  ierr = MatSchurComplementGetKSP(user->DiagBlock_V,&KSP_ETBN);CHKERRQ(ierr);
  //KSPSetType(KSP_ETBN,KSPPREONLY);
  KSPAppendOptionsPrefix(KSP_ETBN, "KSP_ETBN");
  ierr = KSPGetPC(KSP_ETBN,&PC_ETBN);CHKERRQ(ierr);
  PCSetType(PC_ETBN,PCASM);
  PCASMSetOverlap(PC_ETBN,7);
  if(0){
    KSP       *subksp;        /* array of KSP contexts for local subblocks */
    PetscInt  nlocal,first;   /* number of local subblocks, first local subblock */
    PC        subpc;          /* PC context for subblock */
    PetscInt  i;

    PetscPrintf(PETSC_COMM_WORLD,"User explicitly sets subdomain solvers.\n");
    KSPSetUp(KSP_ETBN);
    /*
       Extract the array of KSP contexts for the local blocks
       */
    PCASMGetSubKSP(PC_ETBN,&nlocal,&first,&subksp);
    /*
       Loop over the local blocks, setting various KSP options
       for each block.
       */
    for (i=0; i<nlocal; i++) {
      KSPGetPC(subksp[i],&subpc);
      PCSetType(subpc,PCLU);
      PCFactorSetMatSolverType(subpc,MATSOLVERSUPERLU_DIST);
      KSPSetType(subksp[i],KSPPREONLY);
      //KSPSetTolerances(subksp[i],1.e-7,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);
    }
  }

  //PCSetType(PC_ETBN,PCLU);
  //PCFactorSetMatSolverType(PC_ETBN,MATSOLVERSUPERLU_DIST);

  ierr = KSPCreate(PETSC_COMM_WORLD, & user->KSP_V);CHKERRQ(ierr);
  ierr = KSPSetOperators(user->KSP_V, user->DiagBlock_V, user->DiagBlock_V);CHKERRQ(ierr);
  ierr = KSPGetPC(user->KSP_V, & PC_V);CHKERRQ(ierr);
  PCSetType(PC_V, PCNONE);
  ierr = PCSetUp(PC_V);CHKERRQ(ierr);
  ierr = KSPSetUp(user->KSP_V);CHKERRQ(ierr);
  KSPAppendOptionsPrefix(user->KSP_V, "KSP_V");
  ierr = KSPSetTolerances(user->KSP_V, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT, 200); //use 200 outer iterations for the V solve
  CHKERRQ(ierr);

  if(0){
    KSPConvergedReasonView(user->KSP_V, PETSC_VIEWER_DEFAULT);
    KSPMonitorSet(user->KSP_V, (PetscErrorCode (*)(KSP,PetscInt,PetscReal,void*))KSPMonitorResidual, NULL, NULL);
    KSPView(user->KSP_V, PETSC_VIEWER_STDOUT_WORLD);
  }

  return 0;
}

PetscErrorCode SampleShellPCSetUp_SuperLU(PC pc){
  User * user;
  SNES snes;
  Mat J;
  KSP KSP_ETBN;
  PC PC_ETBN, PC_V, PC_B, PC_EP;
  PetscErrorCode ierr = 0;

  PCShellGetContext(pc,&user);
  Mat myS;

  /* Creating matrices */
  ierr = MatCreate(PETSC_COMM_WORLD,&myS); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->DiagBlock_V); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->OffDiagBlock_L); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->OffDiagBlock_U); CHKERRQ(ierr);

  const IS islist2[5] = {user->isV, user->isEP, user->istau, user->isB, user->isni};
  IS isALL;

  ierr = ISConcatenate(PETSC_COMM_WORLD,5,islist2,&isALL); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields are as follows.\n");
  //ISView(isALL,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = ISDifference(isALL, user->isV, & user->isALL_V); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields except V are as follows.\n");
  //ISView(isALL_V,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = TSGetSNES(user->ts, & snes); CHKERRQ(ierr);
  SNESGetJacobian(snes,&J,NULL,NULL,NULL);

  ierr = MatGetSchurComplement (J, user->isALL_V, user->isALL_V, user->isV, user->isV, MAT_INITIAL_MATRIX, & user->DiagBlock_V, MAT_SCHUR_COMPLEMENT_AINV_DIAG, MAT_INITIAL_MATRIX, &myS); CHKERRQ(ierr);

  ierr = MatDestroy(&myS); CHKERRQ(ierr);
  ierr = ISDestroy( & isALL); CHKERRQ(ierr);

  MatCreateSubMatrix(J,user->isALL_V,user->isV,MAT_INITIAL_MATRIX,& user->OffDiagBlock_U);
  MatCreateSubMatrix(J,user->isV,user->isALL_V,MAT_INITIAL_MATRIX,& user->OffDiagBlock_L);

  /* Creating and setting KSP Solvers*/
  ierr = MatSchurComplementGetKSP(user->DiagBlock_V,&KSP_ETBN);CHKERRQ(ierr);
  KSPSetType(KSP_ETBN,KSPPREONLY);
  KSPAppendOptionsPrefix(KSP_ETBN, "KSP_ETBN");
  ierr = KSPGetPC(KSP_ETBN,&PC_ETBN);CHKERRQ(ierr);
  PCSetType(PC_ETBN,PCLU);
  PCFactorSetMatSolverType(PC_ETBN,MATSOLVERSUPERLU_DIST);

  ierr = KSPCreate(PETSC_COMM_WORLD, & user->KSP_V);CHKERRQ(ierr);
  ierr = KSPSetOperators(user->KSP_V, user->DiagBlock_V, user->DiagBlock_V);CHKERRQ(ierr);
  ierr = KSPGetPC(user->KSP_V, & PC_V);CHKERRQ(ierr);
  PCSetType(PC_V, PCNONE);
  ierr = PCSetUp(PC_V);CHKERRQ(ierr);
  ierr = KSPSetUp(user->KSP_V);CHKERRQ(ierr);
  KSPAppendOptionsPrefix(user->KSP_V, "KSP_V");
  ierr = KSPSetTolerances(user->KSP_V, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT, 200); //use 200 outer iterations for the V solve
  CHKERRQ(ierr);

  return 0;
}

PetscErrorCode SampleShellPCApply(PC pc,Vec x,Vec y){
  User * user;
  Vec x_ETBN, x_V, y_ETBN, y_V;
  Vec z_ETBN, z_V;
  PetscErrorCode ierr = 0;
  KSP KSP_ETBN;

  ierr = PCShellGetContext(pc,&user);CHKERRQ(ierr);
  //VecZeroEntries(y);
  VecCopy(x, y);

  ierr = MatSchurComplementGetKSP(user->DiagBlock_V,&KSP_ETBN);CHKERRQ(ierr);

  VecGetSubVector( y, user -> isALL_V, & y_ETBN);
  VecGetSubVector( x, user -> isALL_V, & x_ETBN);
  VecDuplicate(x_ETBN, & z_ETBN);

  VecGetSubVector( y, user -> isV, & y_V);
  VecGetSubVector( x, user -> isV, & x_V);
  VecDuplicate(x_V, & z_V);

  // y_ETBN := J_{ETBN}^{-1} x_ETBN
  ierr = KSPSolve(KSP_ETBN, x_ETBN, y_ETBN);CHKERRQ(ierr);
  // z_V := x_V - J_{V,ETBN} y_ETBN
  ierr = VecScale(y_ETBN, -1.0);CHKERRQ(ierr);
  ierr = MatMultAdd(user->OffDiagBlock_L,y_ETBN,x_V,z_V);CHKERRQ(ierr);
  ierr = VecScale(y_ETBN, -1.0);CHKERRQ(ierr);
  // y_V := (J_V - J_{V,ETBN} * J_{ETBN}^{-1} J_{ETBN,V} )^{-1} z_V
  ierr = KSPSolve(user->KSP_V, z_V, y_V);CHKERRQ(ierr);
  // z_ETBN := J_{ETBN,V} y_V
  ierr = MatMult(user->OffDiagBlock_U, y_V, z_ETBN);CHKERRQ(ierr);
  // z_ETBN := J_{ETBN}^{-1} z_ETBN
  ierr = KSPSolve(KSP_ETBN, z_ETBN, z_ETBN);CHKERRQ(ierr);
  // y_ETBN := y_ETBN - z_ETBN
  ierr = VecAXPY(y_ETBN, -1.0, z_ETBN);CHKERRQ(ierr);

  VecRestoreSubVector( y, user -> isALL_V, & y_ETBN);
  VecRestoreSubVector( x, user -> isALL_V, & x_ETBN);

  VecRestoreSubVector( y, user -> isV, & y_V);
  VecRestoreSubVector( x, user -> isV, & x_V);

  VecDestroy(& z_V);
  VecDestroy(& z_ETBN);

  return 0;
}

PetscErrorCode SampleShellPCDestroy(PC pc){
  User * user;

  PCShellGetContext(pc,&user);
  /* Destroy matrices */
  MatDestroy( & user->DiagBlock_V);
  MatDestroy( & user->OffDiagBlock_L);
  MatDestroy( & user->OffDiagBlock_U);
  /* Destroy KSP Solvers */
  KSPDestroy( & user->KSP_V);
  /* Destroy Index Set */
  ISDestroy( & user->isALL_V);
  return 0;
}

PetscErrorCode SampleShellPCSetUp_Diag(PC pc){
  User * user;
  SNES snes;
  Mat J;
  KSP KSP_ETBN;
  PC PC_ETBN, PC_V, PC_B, PC_EP;
  PetscErrorCode ierr = 0;

  PCShellGetContext(pc,&user);
  Mat myS;

  /* Creating matrices */
  ierr = MatCreate(PETSC_COMM_WORLD,&myS); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->DiagBlock_V); CHKERRQ(ierr);

  const IS islist2[5] = {user->isV, user->isEP, user->istau, user->isB, user->isni};
  IS isALL;

  ierr = ISConcatenate(PETSC_COMM_WORLD,5,islist2,&isALL); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields are as follows.\n");
  //ISView(isALL,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = ISDifference(isALL, user->isV, & user->isALL_V); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields except V are as follows.\n");
  //ISView(isALL_V,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = TSGetSNES(user->ts, & snes); CHKERRQ(ierr);
  SNESGetJacobian(snes,&J,NULL,NULL,NULL);

  ierr = MatGetSchurComplement (J, user->isALL_V, user->isALL_V, user->isV, user->isV, MAT_INITIAL_MATRIX, & user->DiagBlock_V, MAT_SCHUR_COMPLEMENT_AINV_DIAG, MAT_INITIAL_MATRIX, &myS); CHKERRQ(ierr);

  ierr = MatDestroy(&myS); CHKERRQ(ierr);
  ierr = ISDestroy( & isALL); CHKERRQ(ierr);

  /* Creating and setting KSP Solvers*/
  ierr = MatSchurComplementGetKSP(user->DiagBlock_V,&KSP_ETBN);CHKERRQ(ierr);
  KSPSetType(KSP_ETBN,KSPPREONLY);
  KSPAppendOptionsPrefix(KSP_ETBN, "KSP_ETBN");
  ierr = KSPGetPC(KSP_ETBN,&PC_ETBN);CHKERRQ(ierr);
  PCSetType(PC_ETBN,PCLU);
  PCFactorSetMatSolverType(PC_ETBN,MATSOLVERSUPERLU_DIST);

  ierr = KSPCreate(PETSC_COMM_WORLD, & user->KSP_V);CHKERRQ(ierr);
  ierr = KSPSetOperators(user->KSP_V, user->DiagBlock_V, user->DiagBlock_V);CHKERRQ(ierr);
  ierr = KSPGetPC(user->KSP_V, & PC_V);CHKERRQ(ierr);
  PCSetType(PC_V, PCNONE);
  ierr = PCSetUp(PC_V);CHKERRQ(ierr);
  ierr = KSPSetUp(user->KSP_V);CHKERRQ(ierr);
  KSPAppendOptionsPrefix(user->KSP_V, "KSP_V");
  ierr = KSPSetTolerances(user->KSP_V, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT, 200); //use 200 outer iterations for the V solve
  CHKERRQ(ierr);

  return 0;
}

PetscErrorCode SampleShellPCApply_Diag(PC pc,Vec x,Vec y){
  User * user;
  Vec x_ETBN, x_V, y_ETBN, y_V;
  PetscErrorCode ierr = 0;
  KSP KSP_ETBN;

  ierr = PCShellGetContext(pc,&user);CHKERRQ(ierr);
  //VecZeroEntries(y);
  VecCopy(x, y);

  ierr = MatSchurComplementGetKSP(user->DiagBlock_V,&KSP_ETBN);CHKERRQ(ierr);

  VecGetSubVector( y, user -> isALL_V, & y_ETBN);
  VecGetSubVector( x, user -> isALL_V, & x_ETBN);

  ierr = KSPSolve(KSP_ETBN, x_ETBN, y_ETBN);CHKERRQ(ierr);
  VecRestoreSubVector( y, user -> isALL_V, & y_ETBN);
  VecRestoreSubVector( x, user -> isALL_V, & x_ETBN);


  VecGetSubVector( y, user -> isV, & y_V);
  VecGetSubVector( x, user -> isV, & x_V);

  ierr = KSPSolve(user->KSP_V, x_V, y_V);CHKERRQ(ierr);
  VecRestoreSubVector( y, user -> isV, & y_V);
  VecRestoreSubVector( x, user -> isV, & x_V);


  return 0;
}

PetscErrorCode SampleShellPCDestroy_Diag(PC pc){
  User * user;

  PCShellGetContext(pc,&user);
  /* Destroy matrices */
  MatDestroy( & user->DiagBlock_V);
  /* Destroy KSP Solvers */
  KSPDestroy( & user->KSP_V);
  /* Destroy Index Set */
  ISDestroy( & user->isALL_V);
  return 0;
}

PetscErrorCode SampleShellPCSetUp_ApproximateDiag(PC pc){
  User * user;
  SNES snes;
  Mat J;
  KSP KSP_ETBN;
  PC PC_ETBN, PC_V, PC_B, PC_EP;
  PetscErrorCode ierr = 0;

  PCShellGetContext(pc,&user);
  Mat myS;

  /* Creating matrices */
  ierr = MatCreate(PETSC_COMM_WORLD,&myS); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->DiagBlock_B); CHKERRQ(ierr);
  ierr = MatCreate(PETSC_COMM_WORLD,& user->DiagBlock_V); CHKERRQ(ierr);

  const IS islist2[5] = {user->isV, user->isEP, user->istau, user->isB, user->isni};
  IS isALL, isALL_V;

  ierr = ISConcatenate(PETSC_COMM_WORLD,5,islist2,&isALL); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields are as follows.\n");
  //ISView(isALL,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = ISDifference(isALL, user->isV, & isALL_V); CHKERRQ(ierr);

  //PetscPrintf(PETSC_COMM_WORLD, "The global indices for all fields except V are as follows.\n");
  //ISView(isALL_V,PETSC_VIEWER_STDOUT_SELF);
  //return 0;

  ierr = TSGetSNES(user->ts, & snes); CHKERRQ(ierr);
  SNESGetJacobian(snes,&J,NULL,NULL,NULL);
  //MatCreateSubMatrix(J,user->isV,user->isV,MAT_INITIAL_MATRIX,& user->DiagBlock_V);
  MatCreateSubMatrix(J,user->isEP,user->isEP,MAT_INITIAL_MATRIX,& user->DiagBlock_EP);
  //MatGetSubMatrix(J,user.isB,user.isB,MAT_INITIAL_MATRIX,& user->DiagBlock_B);

  ierr = MatGetSchurComplement (J, user->istau, user->istau, user->isB, user->isB, MAT_INITIAL_MATRIX, &myS,MAT_SCHUR_COMPLEMENT_AINV_DIAG, MAT_INITIAL_MATRIX, & user->DiagBlock_B); CHKERRQ(ierr); // (1/dt)I + \nabla x(eta/mu0 \nabla x ) - \nabla x (V_0 x )

  ierr = MatGetSchurComplement (J, isALL_V, isALL_V, user->isV, user->isV, MAT_INITIAL_MATRIX, & user->DiagBlock_V, MAT_SCHUR_COMPLEMENT_AINV_DIAG, MAT_INITIAL_MATRIX, &myS); CHKERRQ(ierr);

  ierr = MatDestroy(&myS); CHKERRQ(ierr);
  ierr = ISDestroy( & isALL); CHKERRQ(ierr);
  ierr = ISDestroy( & isALL_V); CHKERRQ(ierr);

  /* Creating and setting KSP Solvers*/
  ierr = MatSchurComplementGetKSP(user->DiagBlock_V,&KSP_ETBN);CHKERRQ(ierr);
  KSPSetType(KSP_ETBN,KSPPREONLY);
  KSPAppendOptionsPrefix(KSP_ETBN, "KSP_ETBN");
  ierr = KSPGetPC(KSP_ETBN,&PC_ETBN);CHKERRQ(ierr);
  PCSetType(PC_ETBN,PCLU);
  PCFactorSetMatSolverType(PC_ETBN,MATSOLVERSUPERLU_DIST);

  ierr = KSPCreate(PETSC_COMM_WORLD, & user->KSP_EP);CHKERRQ(ierr);
  ierr = KSPSetOperators(user->KSP_EP, user->DiagBlock_EP, user->DiagBlock_EP);CHKERRQ(ierr);
  ierr = KSPGetPC(user->KSP_EP, & PC_EP);CHKERRQ(ierr);
  PCSetType(PC_EP, PCBJACOBI);
  ierr = PCSetUp(PC_EP);CHKERRQ(ierr);
  ierr = KSPSetUp(user->KSP_EP);CHKERRQ(ierr);
  KSPAppendOptionsPrefix(user->KSP_EP, "KSP_EP");
  ierr = KSPSetTolerances(user->KSP_EP, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT, 200); //use 200 outer iterations for the EP solve
  CHKERRQ(ierr);

  ierr = KSPCreate(PETSC_COMM_WORLD, & user->KSP_B);CHKERRQ(ierr);
  ierr = KSPSetOperators(user->KSP_B, user->DiagBlock_B, user->DiagBlock_B);CHKERRQ(ierr);
  ierr = KSPGetPC(user->KSP_B, & PC_B);CHKERRQ(ierr);
  PCSetType(PC_B, PCHYPRE);
  ierr = PCSetUp(PC_B);CHKERRQ(ierr);
  ierr = KSPSetUp(user->KSP_B);CHKERRQ(ierr);
  KSPAppendOptionsPrefix(user->KSP_B, "KSP_B");
  ierr = KSPSetTolerances(user->KSP_B, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT, 200); //use 200 outer iterations for the B solve
  CHKERRQ(ierr);

  ierr = KSPCreate(PETSC_COMM_WORLD, & user->KSP_V);CHKERRQ(ierr);
  ierr = KSPSetOperators(user->KSP_V, user->DiagBlock_V, user->DiagBlock_V);CHKERRQ(ierr);
  ierr = KSPGetPC(user->KSP_V, & PC_V);CHKERRQ(ierr);
  PCSetType(PC_V, PCNONE);
  ierr = PCSetUp(PC_V);CHKERRQ(ierr);
  ierr = KSPSetUp(user->KSP_V);CHKERRQ(ierr);
  KSPAppendOptionsPrefix(user->KSP_V, "KSP_V");
  ierr = KSPSetTolerances(user->KSP_V, PETSC_DEFAULT, PETSC_DEFAULT, PETSC_DEFAULT, 200); //use 200 outer iterations for the V solve
  CHKERRQ(ierr);

  return 0;
}

PetscErrorCode SampleShellPCApply_ApproximateDiag(PC pc,Vec x,Vec y){
  User * user;
  Vec x_B, x_EP, x_V, y_B, y_EP, y_V, ni;
  PetscErrorCode ierr = 0;

  ierr = PCShellGetContext(pc,&user);CHKERRQ(ierr);
  //VecZeroEntries(y);
  VecCopy(x, y);

  ierr = VecGetSubVector( y, user -> isni, & ni);CHKERRQ(ierr);
  ierr = VecScale(ni, user->dt);CHKERRQ(ierr);
  ierr = VecRestoreSubVector( y, user -> isni, & ni);CHKERRQ(ierr);



  ierr = VecGetSubVector( y, user -> isEP, & y_EP);CHKERRQ(ierr);
  ierr = VecGetSubVector( x, user -> isEP, & x_EP);CHKERRQ(ierr);

  ierr = KSPSolve(user->KSP_EP, x_EP, y_EP);CHKERRQ(ierr);
  VecRestoreSubVector( y, user -> isEP, & y_EP);
  VecRestoreSubVector( x, user -> isEP, & x_EP);


  VecGetSubVector( y, user -> isB, & y_B);
  VecGetSubVector( x, user -> isB, & x_B);

  ierr = KSPSolve(user->KSP_B, x_B, y_B);CHKERRQ(ierr);
  VecRestoreSubVector( y, user -> isB, & y_B);
  VecRestoreSubVector( x, user -> isB, & x_B);


  VecGetSubVector( y, user -> isV, & y_V);
  VecGetSubVector( x, user -> isV, & x_V);

  ierr = KSPSolve(user->KSP_V, x_V, y_V);CHKERRQ(ierr);
  VecRestoreSubVector( y, user -> isV, & y_V);
  VecRestoreSubVector( x, user -> isV, & x_V);


  return 0;
}

PetscErrorCode SampleShellPCDestroy_ApproximateDiag(PC pc){
  User * user;

  PCShellGetContext(pc,&user);
  /* Destroy matrices */
  MatDestroy( & user->DiagBlock_V);
  MatDestroy( & user->DiagBlock_EP);
  MatDestroy( & user->DiagBlock_B);
  /* Destroy KSP Solvers */
  KSPDestroy( & user->KSP_EP);
  KSPDestroy( & user->KSP_V);
  KSPDestroy( & user->KSP_B);
  return 0;
}

PetscErrorCode ReadInitialData(PetscReal ** data, PetscInt * num,
    const char * file_name) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("ReadInitialData",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  PetscInt i;
  char filename[PETSC_MAX_PATH_LEN];

  snprintf(filename, sizeof(filename), "%s", file_name);
  FILE * pFile = fopen(filename, "r");
  if (pFile == NULL) SETERRQ(PETSC_COMM_SELF, 1, "Incorrect location of data");
  fscanf(pFile, "%d", num);

  PetscMalloc1( * num, data);

  i = 0;
  while (fscanf(pFile, "%lf", & (( * data)[i])) == 1) {
    //printf("%lf\n", (*data)[i]);
    i = i + 1;
  }
  fclose(pFile);

  if (i != * num) {
    printf("i = [%d] but num = [%d]\n", i, * num);
  }

  PetscPrintf(PETSC_COMM_WORLD, "============Finished reading in InitialData============\n");

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return(0);
}

PetscErrorCode ReadALine(const char * file_name, PetscInt linenum, PetscReal * output) {
  PetscInt i, num;
  char filename[PETSC_MAX_PATH_LEN];
  PetscReal value;
  PetscBool reached = PETSC_FALSE;

  *output = 1000000;

  //PetscPrintf(PETSC_COMM_WORLD, "Inside ReadALine.\n");

  snprintf(filename, sizeof(filename), "%s", file_name);

  //PetscPrintf(PETSC_COMM_WORLD, "Inside ReadALine: filename = %s.\n",filename);

  //PetscPrintf(PETSC_COMM_WORLD, "Inside ReadALine: after snprintf.\n");

  FILE * pFile = fopen(filename, "r");

  //PetscPrintf(PETSC_COMM_WORLD, "Inside ReadALine: after fopen.\n");

  if (pFile == NULL) SETERRQ(PETSC_COMM_SELF, 1, "Incorrect location of data");
  fscanf(pFile, "%d", &num);

  //PetscPrintf(PETSC_COMM_WORLD, "Inside ReadALine: after fscanf num: num = %d.\n",num);

  i = 0;
  while (fscanf(pFile, "%lf", & value) == 1 && !reached) {
    //printf("%lf\n", (*data)[i]);
    if(linenum == i){
      *output = value;
      reached = PETSC_TRUE;
    }
    else{
      i = i + 1;
    }
  }

  //PetscPrintf(PETSC_COMM_WORLD, "Inside ReadALine: after fscanf value: output = %lf.\n",*output);

  fclose(pFile);

  if (i < linenum){
    printf("i = [%d] but linenum = [%d]\n", i, linenum);
  }

  //PetscPrintf(PETSC_COMM_WORLD, "End of ReadALine.\n");

  return(0);
}

PetscErrorCode FormInitialSolution_LargeData(TS ts, Vec X, void * ptr) {
  User * user = (User * ) ptr;
  DM da;
  PetscInt startr, startphi, startz, nr, nphi, nz;

  Vec xLocal;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];

  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];
  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  PetscScalar ** ** arrCoord, ** ** arrX, time = 0.0;
  PetscInt countz = 0, countphi = 0, countr = 0;

  VecZeroEntries(X);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  for (d = 0; d < 3; ++d) {
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
  }

  if(0 && user->ictype == 9 && user->itime == 0.0){
    char filename[PETSC_MAX_PATH_LEN];
    PetscViewer viewerX;

    /* Read X in binary file */
    PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, 2, 0.23);
    PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
    PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
    VecLoad(X, viewerX);
    /* Destroy the viewer */
    PetscViewerDestroy( & viewerX);
    PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
  }

  if (1) {
    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
       Cancel all components except B
       - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
    Vec tau, EP, ni, Vi_perp;
    VecGetSubVector( X, user -> isEP, & EP);
    VecScale(EP, 0.0);
    VecRestoreSubVector( X, user -> isEP, & EP);
    VecGetSubVector( X, user -> istau, & tau);
    VecScale(tau, 0.0);
    VecRestoreSubVector( X, user -> istau, & tau);
    VecGetSubVector( X, user -> isni, & ni);
    VecScale(ni, 0.0);
    VecRestoreSubVector( X, user -> isni, & ni);
    VecGetSubVector( X, user -> isV, & Vi_perp);
    VecScale(Vi_perp, 0.0);
    VecRestoreSubVector( X, user -> isV, & Vi_perp);
  }
  /* Compute function over the locally owned part of the grid */
  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        if (user -> ictype == 1) {
          /* B(r, phi, z, t) = (cos(pi*t)/r) * ((z-0.5)^2 + sin(phi)) e_r */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrm[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrm[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(PETSC_PI * time) * (PetscSinReal(arrCoord[ez][ephi][er][icBrp[1]]) + PetscSqr(arrCoord[ez][ephi][er][icBrp[2]] - 0.5)) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t) = (cos(pi*t)*(2*z-1)/r) e_phi - (cos(pi*t)*cos(phi)/r^2) e_z */
          arrX[ez][ephi][er][ivErmzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzm[0]];
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphim[0]]);

          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzm[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzm[0]];
            arrX[ez][ephi][er][ivErpphim] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphim[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErmphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErmzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErmzp[0]];
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = -PetscCosReal(arrCoord[ez][ephi][er][icErpphip[1]]) * PetscCosReal(PETSC_PI * time) / PetscSqr(arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = PetscCosReal(PETSC_PI * time) * (2.0 * arrCoord[ez][ephi][er][icErpzp[2]] - 1.0) / arrCoord[ez][ephi][er][icErpzp[0]];
          }
        } else if (user -> ictype == 2) {
          /* B(r, phi, z, t=0) = sin(pi*r) e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphim[0]]);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icBphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = (pi*cos(pi*r) + sin(pi*r)/r) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphim[0]]) / arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphim[0]]) / arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErmphip[0]]) / arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = (PETSC_PI * PetscCosReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) + PetscSinReal(PETSC_PI * arrCoord[ez][ephi][er][icErpphip[0]]) / arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 3) {
          /* B(r, phi, z, t=0) = cos(phi) e_r - sin(phi) e_phi */
          arrX[ez][ephi][er][ivBrm] = PetscCosReal(arrCoord[ez][ephi][er][icBrm[1]]);
          arrX[ez][ephi][er][ivBphim] = -PetscSinReal(arrCoord[ez][ephi][er][icBphim[1]]);
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscCosReal(arrCoord[ez][ephi][er][icBrp[1]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = -PetscSinReal(arrCoord[ez][ephi][er][icBphip[1]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 4) {
          /* B(r, phi, z, t=0) = e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 1.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 1.0;
          }
          /* E(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 5) {
          /* B(r, phi, z, t=0) = (1/r) e_r */
          arrX[ez][ephi][er][ivBrm] = 1.0 / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 1.0 / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 6) {
          /* B(r, phi, z, t=0) = e_phi */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 1.0;
          arrX[ez][ephi][er][ivBzm] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = 0.0;
          }
          /* E(r, phi, z, t=0) = (1/r) e_z */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 1.0 / arrCoord[ez][ephi][er][icErmphim[0]];
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 1.0 / arrCoord[ez][ephi][er][icErpphim[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 1.0 / arrCoord[ez][ephi][er][icErmphip[0]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 1.0 / arrCoord[ez][ephi][er][icErpphip[0]];
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 7) {
          /* B(r, phi, z, t=0) = (1 + sin(phi)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) + 1.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) + 1.0;
          }
          /* E(r, phi, z, t=0) = (cos(phi)/r) e_r */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]) / arrCoord[ez][ephi][er][icEphimzm[0]];
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]) / arrCoord[ez][ephi][er][icEphipzm[0]];
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]) / arrCoord[ez][ephi][er][icEphimzp[0]];
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]) / arrCoord[ez][ephi][er][icEphipzp[0]];
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }
        } else if (user -> ictype == 8) {
          /* B(r, phi, z, t=0) = exp(sin(phi)*r) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 0.0;
          arrX[ez][ephi][er][ivBzm] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icBzm[1]]) * arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icBzp[1]]) * arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* E(r, phi, z, t=0) = exp(sin(phi)*r) * (cos(phi) e_r - sin(phi) e_phi) */
          arrX[ez][ephi][er][ivErmzm] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]) * arrCoord[ez][ephi][er][icErmzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzm[1]]);
          arrX[ez][ephi][er][ivEphimzm] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphimzm[1]]) * arrCoord[ez][ephi][er][icEphimzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzm[1]]);
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]) * arrCoord[ez][ephi][er][icErpzm[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzm[1]]);
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphipzm[1]]) * arrCoord[ez][ephi][er][icEphipzm[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzm[1]]);
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]) * arrCoord[ez][ephi][er][icErmzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErmzp[1]]);
            arrX[ez][ephi][er][ivEphimzp] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphimzp[1]]) * arrCoord[ez][ephi][er][icEphimzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphimzp[1]]);
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icEphipzp[1]]) * arrCoord[ez][ephi][er][icEphipzp[0]]) * PetscCosReal(arrCoord[ez][ephi][er][icEphipzp[1]]);
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = -PetscExpReal(PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]) * arrCoord[ez][ephi][er][icErpzp[0]]) * PetscSinReal(arrCoord[ez][ephi][er][icErpzp[1]]);
          }
        } else if (user -> ictype == 10) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 1.0;
          arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) = 0 */
          /*
             arrX[ez][ephi][er][ivErmzm] = 0.0;
             arrX[ez][ephi][er][ivEphimzm] = 0.0;
             arrX[ez][ephi][er][ivErmphim] = 0.0;
             if (er == N[0] - 1) {
             arrX[ez][ephi][er][ivErpzm] = 0.0;
             arrX[ez][ephi][er][ivErpphim] = 0.0;
             }
             if (ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivEphipzm] = 0.0;
             arrX[ez][ephi][er][ivErmphip] = 0.0;
             }
             if (ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErmzp] = 0.0;
             arrX[ez][ephi][er][ivEphimzp] = 0.0;
             }
             if (er == N[0] - 1 && ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivErpphip] = 0.0;
             }
             if (ephi == N[1] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivEphipzp] = 0.0;
             }
             if (er == N[0] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErpzp] = 0.0;
             }*/

          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        } else if (user -> ictype == 9 && user -> itime == 0.0) {
          if(1){
            /* B(r, phi, z, t=0) Loaded from ReadInitialData output */
            char filename[PETSC_MAX_PATH_LEN];
            PetscSNPrintf(filename, PETSC_MAX_PATH_LEN, "%s/vecBr.txt", user->input_folder);
            ReadALine(filename, er + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1), & arrX[ez][ephi][er][ivBrm] );
            arrX[ez][ephi][er][ivBrm] /= user->B0;
            if (er == N[0] - 1) {
              ReadALine(filename, er + 1 + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1), & arrX[ez][ephi][er][ivBrp] );
              arrX[ez][ephi][er][ivBrp] /= user->B0;
            }

            PetscSNPrintf(filename, PETSC_MAX_PATH_LEN, "%s/vecBphi.txt", user->input_folder);
            ReadALine(filename, er + ephi * N[0] + ez * N[0] * (N[1] + 1), & arrX[ez][ephi][er][ivBphim] );
            arrX[ez][ephi][er][ivBphim] /= user->B0;
            if (ephi == N[1] - 1) {
              ReadALine(filename, er + (ephi + 1) * N[0] + ez * N[0] * (N[1] + 1), & arrX[ez][ephi][er][ivBphip] );
              arrX[ez][ephi][er][ivBphip] /= user->B0;
            }

            PetscSNPrintf(filename, PETSC_MAX_PATH_LEN, "%s/vecBz.txt", user->input_folder);
            ReadALine(filename, er + ephi * N[0] + ez * N[0] * N[1], & arrX[ez][ephi][er][ivBzm] );
            arrX[ez][ephi][er][ivBzm] /=  user->B0;
            if (ez == N[2] - 1) {
              ReadALine(filename, er + ephi * N[0] + (ez + 1) * N[0] * N[1], & arrX[ez][ephi][er][ivBzp] );
              arrX[ez][ephi][er][ivBzp] /= user->B0;
            }
          }
          /* tau(r, phi, z, t=0) initialized with zero values. The tau field will be computed later from B field with the derived curl operator */
          arrX[ez][ephi][er][ivErmzm] = 0.0;
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = 0.0;
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = 0.0;
            arrX[ez][ephi][er][ivErpphim] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = 0.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = 0.0;
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = 0.0;
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = 0.0;
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        } else if (user -> ictype == 11) {
          /* B(r, phi, z, t=0) = (2+cos(eta/mu0 * t)) * [e_phi + sqrt(2*ln(2*r_max/r)) e_z] */
          arrX[ez][ephi][er][ivBrm] = 0.0;
          arrX[ez][ephi][er][ivBphim] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          arrX[ez][ephi][er][ivBzm] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = 0.0;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 2.0 + PetscCosReal((user->eta / user->mu0) * time);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = (2.0 + PetscCosReal((user->eta / user->mu0) * time)) * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]));
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) * (cos(eta/mu0 * t)+2) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, BACK_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, DOWN_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, BACK_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, DOWN_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, UP_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, FRONT_LEFT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, UP_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) * (2.0 + PetscCosReal(condu(er, ephi, ez, FRONT_RIGHT, user) / user->mu0 * time)) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }
        else if (user -> ictype == 12) {
          /* B(r, phi, z, t=0) = exp(- z / z_max) / r e_r + (r - z) e_phi + cos(2*r_max/r) e_z */
          arrX[ez][ephi][er][ivBrm] = PetscExpReal(- arrCoord[ez][ephi][er][icBrm[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrm[0]];
          arrX[ez][ephi][er][ivBphim] = arrCoord[ez][ephi][er][icBphim[0]] - arrCoord[ez][ephi][er][icBphim[2]];
          arrX[ez][ephi][er][ivBzm] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = PetscExpReal(- arrCoord[ez][ephi][er][icBrp[2]] / user->zmax) / arrCoord[ez][ephi][er][icBrp[0]];
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = arrCoord[ez][ephi][er][icBphip[0]] - arrCoord[ez][ephi][er][icBphip[2]];
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = PetscCosReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzp[0]]);
          }
          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }

        else if (user -> ictype == 13) {
          /* B(r, phi, z, t=0) = e_phi + sqrt(2*ln(2*r_max/r)) e_z */
          if(er!=0) {
            arrX[ez][ephi][er][ivBrm] = 0.0;
          }
          arrX[ez][ephi][er][ivBphim] = 1.0;
          if(ez!=0) {
            arrX[ez][ephi][er][ivBzm] = PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icBzm[0]]));
          }
          if(er==0) {
            arrX[ez][ephi][er][ivBrm] = NAN;
          }
          if(ez==0) {
            arrX[ez][ephi][er][ivBzm] = NAN;
          }
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivBrp] = NAN;
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivBphip] = 1.0;
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivBzp] = NAN;
          }
          /* tau(r, phi, z, t=0) = 0 */
          /*
             arrX[ez][ephi][er][ivErmzm] = 0.0;
             arrX[ez][ephi][er][ivEphimzm] = 0.0;
             arrX[ez][ephi][er][ivErmphim] = 0.0;
             if (er == N[0] - 1) {
             arrX[ez][ephi][er][ivErpzm] = 0.0;
             arrX[ez][ephi][er][ivErpphim] = 0.0;
             }
             if (ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivEphipzm] = 0.0;
             arrX[ez][ephi][er][ivErmphip] = 0.0;
             }
             if (ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErmzp] = 0.0;
             arrX[ez][ephi][er][ivEphimzp] = 0.0;
             }
             if (er == N[0] - 1 && ephi == N[1] - 1) {
             arrX[ez][ephi][er][ivErpphip] = 0.0;
             }
             if (ephi == N[1] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivEphipzp] = 0.0;
             }
             if (er == N[0] - 1 && ez == N[2] - 1) {
             arrX[ez][ephi][er][ivErpzp] = 0.0;
             }*/

          /* tau(r, phi, z, t=0) = eta / (mu0 * V_A) / r * [e_z + sqrt(2*ln(2*r_max/r))^{-1} e_phi] */
          arrX[ez][ephi][er][ivErmzm] = condu(er, ephi, ez, BACK_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzm[0]])));
          arrX[ez][ephi][er][ivEphimzm] = 0.0;
          arrX[ez][ephi][er][ivErmphim] = condu(er, ephi, ez, DOWN_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphim[0]]);
          if (er == N[0] - 1) {
            arrX[ez][ephi][er][ivErpzm] = condu(er, ephi, ez, BACK_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzm[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzm[0]])));
            arrX[ez][ephi][er][ivErpphim] = condu(er, ephi, ez, DOWN_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphim[0]]);
          }
          if (ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivEphipzm] = 0.0;
            arrX[ez][ephi][er][ivErmphip] = condu(er, ephi, ez, UP_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmphip[0]]);
          }
          if (ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErmzp] = condu(er, ephi, ez, FRONT_LEFT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErmzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErmzp[0]])));
            arrX[ez][ephi][er][ivEphimzp] = 0.0;
          }
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrX[ez][ephi][er][ivErpphip] = condu(er, ephi, ez, UP_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpphip[0]]);
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivEphipzp] = 0.0;
          }
          if (er == N[0] - 1 && ez == N[2] - 1) {
            arrX[ez][ephi][er][ivErpzp] = condu(er, ephi, ez, FRONT_RIGHT, user) / (11000000.0 * user->mu0 * arrCoord[ez][ephi][er][icErpzp[0]] * PetscSqrtScalar(2.0 * PetscLogReal(2.0 * user->rmax / arrCoord[ez][ephi][er][icErpzp[0]])));
          }

          /* n_i(r, phi, z, t=0) = ni_0 */
          arrX[ez][ephi][er][ivn] = 1.0;

          /* Vi_perp(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrmphipzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphimzp[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzm[2]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[0]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[1]] = 0.0;
          arrX[ez][ephi][er][ivVrpphipzp[2]] = 0.0;

          /* EP(r, phi, z, t=0) = 0 */
          arrX[ez][ephi][er][ivVrmphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrmphipzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphimzp[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzm[3]] = 0.0;

          arrX[ez][ephi][er][ivVrpphipzp[3]] = 0.0;
        }
        else if (user -> ictype > 13) PetscPrintf(PETSC_COMM_WORLD, "Test case not set\n");

      }
    }
  }

  /* Restore vectors */
  DMStagVecRestoreArray(da, xLocal, & arrX);
  if (user -> itime == 0.0) {
    DMLocalToGlobal(da, xLocal, INSERT_VALUES, X);
    DMRestoreLocalVector(da, & xLocal);
  } else {
    char filename[PETSC_MAX_PATH_LEN];
    PetscViewer viewerX;

    /* Read X in binary file */
    PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, (int)(user -> oldstep), (double) user -> itime);
    PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
    PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
    VecLoad(X, viewerX);
    /* Destroy the viewer */
    PetscViewerDestroy( & viewerX);
    PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
  }

  if (0 && user -> ictype == 10 && user -> itime == 0.0) {
    Vec Xcopy;
    VecDuplicate(X, & Xcopy);
    VecCopy(X, Xcopy);
    VecScale(Xcopy, 1.0 / 11000000.0);
    FormDerivedCurl(ts, Xcopy, X, user); //This updates only the tau field part in X by computing the derived mimetic curl operator applied to B field of Xcopy
                                         //PetscBarrier((PetscObject) Xcopy);
    VecDestroy( & Xcopy);
  }

  if ((user -> ictype == 9 || user -> ictype == 15) && user -> itime == 0.0) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);

    TSSetProblemType(dummyts, TS_LINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSSetType(dummyts, TSBEULER);
    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_InitializeEP_LargeData, user);
    TSSetTime(dummyts, 0.0);
    TSSetMaxTime(dummyts, 1e-2);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 1e-2);
    TSSetSolution(dummyts, X);

    //TSGetSNES(dummyts, & dummysnes);
    //SNESGetKSP(dummysnes, & dummyKSP);
    TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);
    //PCSetType(dummypc, PCNONE);

    PCSetType(dummypc,PCBJACOBI);
    //PCASMSetOverlap(dummypc,7);
    //PCFactorSetMatSolverType(dummypc,MATSOLVERMUMPS);
    //PCFactorSetUpMatSolverType(dummypc);

    if(0){
      KSP       *subksp;        /* array of KSP contexts for local subblocks */
      PetscInt  nlocal,first;   /* number of local subblocks, first local subblock */
      PC        subpc;          /* PC context for subblock */
      PetscInt  i;

      PetscPrintf(PETSC_COMM_WORLD,"User explicitly sets subdomain solvers.\n");
      KSPSetUp(dummyKSP);
      /*
         Extract the array of KSP contexts for the local blocks
         */
      PCASMGetSubKSP(dummypc,&nlocal,&first,&subksp);
      /*
         Loop over the local blocks, setting various KSP options
         for each block.
         */
      for (i=0; i<nlocal; i++) {
        KSPGetPC(subksp[i],&subpc);
        PCSetType(subpc,PCLU);
        PCFactorSetMatSolverType(subpc,MATSOLVERSUPERLU_DIST);
        KSPSetType(subksp[i],KSPPREONLY);
        //KSPSetTolerances(subksp[i],1.e-7,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);
      }
    }

    KSPSetTolerances(dummyKSP,1e-8,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");
    KSPSetFromOptions(dummyKSP);

    TSSolve(dummyts, X);

    KSPConvergedReasonView(dummyKSP, PETSC_VIEWER_DEFAULT);
    KSPMonitorSet(dummyKSP, (PetscErrorCode (*)(KSP,PetscInt,PetscReal,void*))KSPMonitorResidual, NULL, NULL);
    KSPView(dummyKSP, PETSC_VIEWER_STDOUT_WORLD);

    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
  }

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  if (user -> debug) {
    /*This print is just for debugging*/
    PetscPrintf(PETSC_COMM_WORLD, "Initial solution vector\n");
    VecView(X, PETSC_VIEWER_STDOUT_WORLD);
  }
  return (0);
}

PetscErrorCode FormIFunction_InitializeEP_LargeData(TS ts, PetscReal t, Vec X, Vec Xdot, Vec F, void * ptr) {
  User * user = (User * ) ptr;
  DM da, coordDA = user -> coorda;
  PetscInt startr, startphi, startz, nr, nphi, nz;
  PetscScalar dt, cellvolume;
  Vec fLocal, xLocal, bcLocal, xdotLocal, pLocal;
  Vec VxBe, VxBeLocal, VxB, Vf, VfLocal, nif, nifLocal, niv, nivLocal, Bv, BvLocal, curlBv, curlBvLocal, GradEP, GradEPLocal, Fcopy, FcopyLocal;
  Vec x, potential;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icp[3];
  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];
  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];

  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];
  PetscInt icrmphimzm[3], icrmphimzp[3], icrmphipzm[3], icrmphipzp[3];
  PetscInt icrpphimzm[3], icrpphimzp[3], icrpphipzm[3], icrpphipzp[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  DM dmCoorda;
  Vec coordaLocal;
  PetscScalar ** ** arrCoorda;

  PetscScalar ** ** arrCoord, ** ** arrF, ** ** arrX, ** ** arrP, ** ** arrx, rmzmedgelength, rmphimedgelength, rmzpedgelength, rmphipedgelength, phimzmedgelength, phimzpedgelength, rpphimedgelength, rpzmedgelength, phipzmedgelength, rpzpedgelength, rpphipedgelength, phipzpedgelength, ** ** arrXdot, ** ** arrBv, ** ** arrcurlBv, ** ** arrnif, ** ** arrniv, ** ** arrVf, ** ** arrVxBe, ** ** arrGradEP, ** ** arrFcopy;

  VecZeroEntries(F);
  TSGetDM(ts, & da);

  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);

  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  DMGetCoordinateDM(coordDA, & dmCoorda);
  DMGetCoordinatesLocal(coordDA, & coordaLocal);
  DMStagVecGetArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  for (d = 0; d < 3; ++d) {
    /* Element coordinates */
    DMStagGetLocationSlot(dmCoorda, ELEMENT, d, & icp[d]);
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
    /* Vertex coordinates */
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_LEFT, d, & icrmphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_DOWN_RIGHT, d, & icrpphimzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_LEFT, d, & icrmphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, BACK_UP_RIGHT, d, & icrpphipzm[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_LEFT, d, & icrmphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_DOWN_RIGHT, d, & icrpphimzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_LEFT, d, & icrmphipzp[d]);
    DMStagGetLocationSlot(dmCoorda, FRONT_UP_RIGHT, d, & icrpphipzp[d]);
  }
  /* Compute the source term potential for time-dependent manufactured solution */
  DMCreateGlobalVector(da, & potential);
  FormSourceTermPotential(ts, t, potential, user);
  DMGetLocalVector(da, & pLocal);
  DMGlobalToLocalBegin(da, potential, INSERT_VALUES, pLocal);
  DMGlobalToLocalEnd(da, potential, INSERT_VALUES, pLocal);
  DMStagVecGetArrayRead(da, pLocal, & arrP);

  /* Compute the exact solution to set boundary conditions */
  DMCreateGlobalVector(da, & x);
  FormExactSolution_LargeData(t, ts, & x, user);
  DMGetLocalVector(da, & bcLocal);
  DMGlobalToLocalBegin(da, x, INSERT_VALUES, bcLocal);
  DMGlobalToLocalEnd(da, x, INSERT_VALUES, bcLocal);
  DMStagVecGetArrayRead(da, bcLocal, & arrx);
  TSGetTimeStep(ts, & dt);
  {
    /* Compute the gradient of EP */
    VecDuplicate(X, & GradEP);
    VecCopy(X, GradEP);
    FormDiscreteGradientEP_noMat(ts, X, GradEP, user);
    DMGetLocalVector(da, & GradEPLocal);
    DMGlobalToLocalBegin(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMGlobalToLocalEnd(da, GradEP, INSERT_VALUES, GradEPLocal);
    DMStagVecGetArrayRead(da, GradEPLocal, & arrGradEP);
  }

  /* Compute function over the locally owned part of the grid */
  /* f1(V,EP,tau,B,ni) = V; on all vertices
     f2(V,EP,tau,B,ni) = -derived_mimetic_div(primary_mimetic_grad(EP)) - (1/V_A) * derived_mimetic_div(derived_mimetic_curl(B)); on all vertices
     f3(V,EP,tau,B,ni) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - primary_mimetic_grad(EP) - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; on all edges
     f4(V,EP,tau,B,ni) = dB/dt; on all faces
     f5(V,EP,tau,B,ni) = dni/dt; in all cells */
  DMGetLocalVector(da, & fLocal);
  DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
  DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
  DMStagVecGetArray(da, fLocal, & arrF);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArrayRead(da, xLocal, & arrX);

  DMGetLocalVector(da, & xdotLocal);
  DMGlobalToLocalBegin(da, Xdot, INSERT_VALUES, xdotLocal);
  DMGlobalToLocalEnd(da, Xdot, INSERT_VALUES, xdotLocal);
  DMStagVecGetArrayRead(da, xdotLocal, & arrXdot);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          cellvolume = user -> dphi * PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        } else {
          cellvolume = PetscAbsReal(arrCoord[ez][ephi][er][icBzp[2]] - arrCoord[ez][ephi][er][icBzm[2]]) *
            PetscAbsReal(arrCoord[ez][ephi][er][icBphip[1]] - arrCoord[ez][ephi][er][icBphim[1]]) * PetscAbsReal(PetscSqr(arrCoord[ez][ephi][er][icBrp[0]]) - PetscSqr(arrCoord[ez][ephi][er][icBrm[0]])) / 2.0; /* INT_c(r dphi dr dz) */
        }

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]);
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* Set boundary conditions for tau field */
        /* f3(V,EP,tau,B,ni) = tau */
        if (er == 0 || ez == 0) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (er == 0 || ephi == 0) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ephi == 0 || ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
        } else {
          if (er == 0) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim];
            if (user -> debug) {
              PetscPrintf(PETSC_COMM_WORLD, "F(Ermphim,%d,%d,%d) = %g\n", er, ephi, ez, (double) arrF[ez][ephi][er][ivErmphim]);
            }
          }
          if (ez == 0) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm];
          }
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivErpzm] = arrX[ez][ephi][er][ivErpzm];
          arrF[ez][ephi][er][ivErpphim] = arrX[ez][ephi][er][ivErpphim];
        }
        if (!(user -> phibtype)) {
          if (ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivEphipzm] = arrX[ez][ephi][er][ivEphipzm];
            arrF[ez][ephi][er][ivErmphip] = arrX[ez][ephi][er][ivErmphip];
          }
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErmzp] = arrX[ez][ephi][er][ivErmzp];
          arrF[ez][ephi][er][ivEphimzp] = arrX[ez][ephi][er][ivEphimzp];
        }
        if (!(user -> phibtype)) {
          if (er == N[0] - 1 && ephi == N[1] - 1) {
            arrF[ez][ephi][er][ivErpphip] = arrX[ez][ephi][er][ivErpphip];
          }
          if (ephi == N[1] - 1 && ez == N[2] - 1) {
            arrF[ez][ephi][er][ivEphipzp] = arrX[ez][ephi][er][ivEphipzp];
          }
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivErpzp] = arrX[ez][ephi][er][ivErpzp];
        }

        /* f1(V,EP,tau,B,ni) = V; on all vertices
           f5(V,EP,tau,B,ni) = dni/dt ; in all cells
           */
        arrF[ez][ephi][er][ivn] = arrXdot[ez][ephi][er][ivn];

        arrF[ez][ephi][er][ivVrmphimzm[0]] = arrX[ez][ephi][er][ivVrmphimzm[0]];
        arrF[ez][ephi][er][ivVrmphimzm[1]] = arrX[ez][ephi][er][ivVrmphimzm[1]];
        arrF[ez][ephi][er][ivVrmphimzm[2]] = arrX[ez][ephi][er][ivVrmphimzm[2]];
        arrF[ez][ephi][er][ivVrmphimzp[0]] = arrX[ez][ephi][er][ivVrmphimzp[0]];
        arrF[ez][ephi][er][ivVrmphimzp[1]] = arrX[ez][ephi][er][ivVrmphimzp[1]];
        arrF[ez][ephi][er][ivVrmphimzp[2]] = arrX[ez][ephi][er][ivVrmphimzp[2]];
        arrF[ez][ephi][er][ivVrmphipzm[0]] = arrX[ez][ephi][er][ivVrmphipzm[0]];
        arrF[ez][ephi][er][ivVrmphipzm[1]] = arrX[ez][ephi][er][ivVrmphipzm[1]];
        arrF[ez][ephi][er][ivVrmphipzm[2]] = arrX[ez][ephi][er][ivVrmphipzm[2]];
        arrF[ez][ephi][er][ivVrmphipzp[0]] = arrX[ez][ephi][er][ivVrmphipzp[0]];
        arrF[ez][ephi][er][ivVrmphipzp[1]] = arrX[ez][ephi][er][ivVrmphipzp[1]];
        arrF[ez][ephi][er][ivVrmphipzp[2]] = arrX[ez][ephi][er][ivVrmphipzp[2]];
        arrF[ez][ephi][er][ivVrpphimzm[0]] = arrX[ez][ephi][er][ivVrpphimzm[0]];
        arrF[ez][ephi][er][ivVrpphimzm[1]] = arrX[ez][ephi][er][ivVrpphimzm[1]];
        arrF[ez][ephi][er][ivVrpphimzm[2]] = arrX[ez][ephi][er][ivVrpphimzm[2]];
        arrF[ez][ephi][er][ivVrpphimzp[0]] = arrX[ez][ephi][er][ivVrpphimzp[0]];
        arrF[ez][ephi][er][ivVrpphimzp[1]] = arrX[ez][ephi][er][ivVrpphimzp[1]];
        arrF[ez][ephi][er][ivVrpphimzp[2]] = arrX[ez][ephi][er][ivVrpphimzp[2]];
        arrF[ez][ephi][er][ivVrpphipzm[0]] = arrX[ez][ephi][er][ivVrpphipzm[0]];
        arrF[ez][ephi][er][ivVrpphipzm[1]] = arrX[ez][ephi][er][ivVrpphipzm[1]];
        arrF[ez][ephi][er][ivVrpphipzm[2]] = arrX[ez][ephi][er][ivVrpphipzm[2]];
        arrF[ez][ephi][er][ivVrpphipzp[0]] = arrX[ez][ephi][er][ivVrpphipzp[0]];
        arrF[ez][ephi][er][ivVrpphipzp[1]] = arrX[ez][ephi][er][ivVrpphipzp[1]];
        arrF[ez][ephi][er][ivVrpphipzp[2]] = arrX[ez][ephi][er][ivVrpphipzp[2]];

        /* f4(V,EP,tau,B,ni) = dB/dt */
        arrF[ez][ephi][er][ivBrm] = arrXdot[ez][ephi][er][ivBrm]; /* Left face */

        arrF[ez][ephi][er][ivBphim] = arrXdot[ez][ephi][er][ivBphim]; /* Down face */

        arrF[ez][ephi][er][ivBzm] = arrXdot[ez][ephi][er][ivBzm]; /* Back face */

        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivBrp] = arrXdot[ez][ephi][er][ivBrp]; /* Right face */
        }

        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivBphip] = arrXdot[ez][ephi][er][ivBphip]; /* Up face */
        }

        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivBzp] = arrXdot[ez][ephi][er][ivBzp]; /* Front face */
        }

        /* Set boundary conditions for EP field */
        /* f2(V,EP,tau,B,ni) = (EP - EPboundarycondition) */
        if (er == 0 || ez == 0 || (ephi == 0 && !(user -> phibtype))) {
          arrF[ez][ephi][er][ivVrmphimzm[3]] = arrX[ez][ephi][er][ivVrmphimzm[3]];
        }
        if (er == N[0] - 1) {
          arrF[ez][ephi][er][ivVrpphimzm[3]] = arrX[ez][ephi][er][ivVrpphimzm[3]];
        }
        if (ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrmphimzp[3]] = arrX[ez][ephi][er][ivVrmphimzp[3]];
        }
        if (ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzm[3]] = arrX[ez][ephi][er][ivVrmphipzm[3]];
        }
        if (ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrmphipzp[3]] = arrX[ez][ephi][er][ivVrmphipzp[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrF[ez][ephi][er][ivVrpphimzp[3]] = arrX[ez][ephi][er][ivVrpphimzp[3]];
        }
        if (er == N[0] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzm[3]] = arrX[ez][ephi][er][ivVrpphipzm[3]];
        }
        if (er == N[0] - 1 && ez == N[2] - 1 && ephi == N[1] - 1 && !(user -> phibtype)) {
          arrF[ez][ephi][er][ivVrpphipzp[3]] = arrX[ez][ephi][er][ivVrpphipzp[3]];
        }
      }
    }
  }
  /* End of triple for loop */

  DMStagVecRestoreArray(da, pLocal, & arrP);
  DMRestoreLocalVector(da, & pLocal);
  //PetscBarrier((PetscObject) potential);
  VecDestroy( & potential);

  if (user -> phibtype) {
    DMStagVecRestoreArray(da, fLocal, & arrF);
    DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);
    /*DMRestoreLocalVector(da,&fLocal);*/

    /*DMGetLocalVector(da,&fLocal);*/
    DMGlobalToLocalBegin(da, F, INSERT_VALUES, fLocal);
    DMGlobalToLocalEnd(da, F, INSERT_VALUES, fLocal);
    DMStagVecGetArray(da, fLocal, & arrF);
  }

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzm[0]];
        } else {
          rmzmedgelength = arrCoorda[ez][ephi][er][icrmphimzm[0]] * (arrCoorda[ez][ephi][er][icrmphipzm[1]] - arrCoorda[ez][ephi][er][icrmphimzm[1]]); /* back left = rmzm */
        }

        rmphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]]); /* down left = rmphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rmzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrmphimzp[0]];
        } else {
          rmzpedgelength = arrCoorda[ez][ephi][er][icrmphimzp[0]] * (arrCoorda[ez][ephi][er][icrmphipzp[1]] - arrCoorda[ez][ephi][er][icrmphimzp[1]]); /* front left = rmzp */
        }

        rmphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]]); /* up left = rmphip */

        phimzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzm[0]], arrCoorda[ez][ephi][er][icrmphimzm[1]], arrCoorda[ez][ephi][er][icrmphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]]); /* back down = phimzm */

        phimzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphimzp[0]], arrCoorda[ez][ephi][er][icrmphimzp[1]], arrCoorda[ez][ephi][er][icrmphimzp[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* front down = phimzp */

        rpphimedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphimzm[0]], arrCoorda[ez][ephi][er][icrpphimzm[1]], arrCoorda[ez][ephi][er][icrpphimzm[2]], arrCoorda[ez][ephi][er][icrpphimzp[0]], arrCoorda[ez][ephi][er][icrpphimzp[1]], arrCoorda[ez][ephi][er][icrpphimzp[2]]); /* down right = rpphim */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzmedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzm[0]];
        } else {
          rpzmedgelength = arrCoorda[ez][ephi][er][icrpphimzm[0]] * (arrCoorda[ez][ephi][er][icrpphipzm[1]] - arrCoorda[ez][ephi][er][icrpphimzm[1]]); /* back right = rpzm */
        }

        phipzmedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzm[0]], arrCoorda[ez][ephi][er][icrmphipzm[1]], arrCoorda[ez][ephi][er][icrmphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]]); /* back up = phipzm */

        if (ephi == -1 || ephi == N[1] - 1 || ephi == N[1]) {
          rpzpedgelength = user -> dphi * arrCoorda[ez][ephi][er][icrpphimzp[0]];
        } else {
          rpzpedgelength = arrCoorda[ez][ephi][er][icrpphimzp[0]] * (arrCoorda[ez][ephi][er][icrpphipzp[1]] - arrCoorda[ez][ephi][er][icrpphimzp[1]]); /* front right = rpzp */
        }

        rpphipedgelength = cyldistance(arrCoorda[ez][ephi][er][icrpphipzm[0]], arrCoorda[ez][ephi][er][icrpphipzm[1]], arrCoorda[ez][ephi][er][icrpphipzm[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* up right = rpphip */

        phipzpedgelength = cyldistance(arrCoorda[ez][ephi][er][icrmphipzp[0]], arrCoorda[ez][ephi][er][icrmphipzp[1]], arrCoorda[ez][ephi][er][icrmphipzp[2]], arrCoorda[ez][ephi][er][icrpphipzp[0]], arrCoorda[ez][ephi][er][icrpphipzp[1]], arrCoorda[ez][ephi][er][icrpphipzp[2]]); /* front up = phipzp */

        /* f3(V,EP,tau,B,ni) = tau - (1/(L0*V_A)) * derived_mimetic_curl(B) = tau - (1/(L0*V_A)) * primary_mimetic_curl^T (beta_f B)/beta_e ≡ tau - (1/(L0*V_A)) * M_e^{-1} Curl^T M_f B; for all inner edges */
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] = arrX[ez][ephi][er][ivErmzm] - ((arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) -
                arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) -
                arrX[ez - 1][ephi][er][ivBrm] * betaf(er, ephi, ez - 1, LEFT, user) / surface(er, ephi, ez - 1, LEFT, user) +
                arrX[ez][ephi][er - 1][ivBzm] * betaf(er - 1, ephi, ez, BACK, user) / surface(er - 1, ephi, ez, BACK, user)) * rmzmedgelength / betae(er, ephi, ez, BACK_LEFT, user)) / 11000000.0;
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] = arrX[ez][ephi][er][ivEphimzm] - ((-arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi][er][ivBzm] * betaf(er, ephi, ez, BACK, user) / surface(er, ephi, ez, BACK, user) +
                  arrX[ez - 1][ephi][er][ivBphim] * betaf(er, ephi, ez - 1, DOWN, user) / surface(er, ephi, ez - 1, DOWN, user) -
                  arrX[ez][ephi - 1][er][ivBzm] * betaf(er, ephi - 1, ez, BACK, user) / surface(er, ephi - 1, ez, BACK, user)) * phimzmedgelength / betae(er, ephi, ez, BACK_DOWN, user)) / 11000000.0;
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] = arrX[ez][ephi][er][ivErmphim] - ((-arrX[ez][ephi][er][ivBrm] * betaf(er, ephi, ez, LEFT, user) / surface(er, ephi, ez, LEFT, user) +
                  arrX[ez][ephi][er][ivBphim] * betaf(er, ephi, ez, DOWN, user) / surface(er, ephi, ez, DOWN, user) +
                  arrX[ez][ephi - 1][er][ivBrm] * betaf(er, ephi - 1, ez, LEFT, user) / surface(er, ephi - 1, ez, LEFT, user) -
                  arrX[ez][ephi][er - 1][ivBphim] * betaf(er - 1, ephi, ez, DOWN, user) / surface(er - 1, ephi, ez, DOWN, user)) * rmphimedgelength / betae(er, ephi, ez, DOWN_LEFT, user)) / 11000000.0;
          }
        }
      }
    }
  }
  //PetscBarrier((PetscObject) F);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3(V,EP,tau,B,ni) -= prim_grad(EP) ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrF[ez][ephi][er][ivErmzm] -= arrGradEP[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrF[ez][ephi][er][ivEphimzm] -= arrGradEP[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrF[ez][ephi][er][ivErmphim] -= arrGradEP[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }

  DMStagVecRestoreArray(da, fLocal, & arrF);
  DMLocalToGlobal(da, fLocal, INSERT_VALUES, F);

  VecDuplicate(F, & Fcopy);
  VecCopy(F, Fcopy);
  //VecScale(Fcopy, -1.0);

  DMGetLocalVector(da, & FcopyLocal);
  DMGlobalToLocalBegin(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMGlobalToLocalEnd(da, Fcopy, INSERT_VALUES, FcopyLocal);
  DMStagVecGetArray(da, FcopyLocal, & arrFcopy);

  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        //F3copy(V,EP,tau,B,ni) -= tau ; on inner edges
        if (!(er == 0 || ez == 0)) {
          arrFcopy[ez][ephi][er][ivErmzm] -= arrX[ez][ephi][er][ivErmzm];
        }
        if (!(user -> phibtype)) {
          if (!(ephi == 0 || ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0 || ephi == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        } else {
          if (!(ez == 0)) {
            arrFcopy[ez][ephi][er][ivEphimzm] -= arrX[ez][ephi][er][ivEphimzm];
          }
          if (!(er == 0)) {
            arrFcopy[ez][ephi][er][ivErmphim] -= arrX[ez][ephi][er][ivErmphim];
          }
        }
      }
    }
  }
  DMStagVecRestoreArray(da, FcopyLocal, & arrFcopy);
  DMLocalToGlobal(da, FcopyLocal, INSERT_VALUES, Fcopy);
  DMRestoreLocalVector(da, & FcopyLocal);

  ApplyDerivedDivergence(ts, Fcopy, F, user);

  /* Restore vectors */
  VecDestroy(& Fcopy);
  DMStagVecRestoreArrayRead(da, GradEPLocal, & arrGradEP);
  DMRestoreLocalVector(da, & GradEPLocal);
  VecDestroy( & GradEP);
  DMRestoreLocalVector(da, & fLocal);
  DMStagVecRestoreArrayRead(da, xLocal, & arrX);
  DMRestoreLocalVector(da, & xLocal);
  DMStagVecRestoreArrayRead(da, xdotLocal, & arrXdot);
  DMRestoreLocalVector(da, & xdotLocal);
  DMStagVecRestoreArrayRead(da, bcLocal, & arrx);
  DMRestoreLocalVector(da, & bcLocal);

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  DMStagVecRestoreArrayRead(dmCoorda, coordaLocal, & arrCoorda);
  if (user -> debug) {
    PetscPrintf(PETSC_COMM_WORLD, "F = \n");
    VecView(F, PETSC_VIEWER_STDOUT_WORLD);
  }

  //PetscBarrier((PetscObject) x);
  VecDestroy( & x);
  return (0);
}

PetscErrorCode FormInitialSolution_psi(TS ts, Vec X, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormInitialSolution_psi",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da;
  PetscInt startr, startphi, startz, nr, nphi, nz;

  Vec xLocal, XcopyLocal, Xcopy;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];

  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];
  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  PetscScalar ** ** arrCoord, ** ** arrX, ** ** arrXcopy, time = 0.0;
  PetscInt countg = 0, countpsi = 0;

  VecZeroEntries(X);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  for (d = 0; d < 3; ++d) {
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
  }

  VecDuplicate(X, & Xcopy);

  /* Compute function over the locally owned part of the grid */
  DMGetLocalVector(da, & XcopyLocal);
  DMGlobalToLocalBegin(da, Xcopy, INSERT_VALUES, XcopyLocal);
  DMGlobalToLocalEnd(da, Xcopy, INSERT_VALUES, XcopyLocal);
  DMStagVecGetArray(da, XcopyLocal , & arrXcopy);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);
  //Set X's magnetic field with G(psi)/r e_phi
  //Set Xcopy's tau field with psi/r e_phi
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        /* G(psi(r, z, t=0)) Loaded from ReadInitialData output */
        arrX[ez][ephi][er][ivBphim] = user -> datag[er + ephi * N[0] + ez * N[0] * (N[1] + 1)] / (arrCoord[ez][ephi][er][icBphim[0]] * user->L0);
        countg = countg + 1;

        if (ephi == N[1] - 1) {
          arrX[ez][ephi][er][ivBphip] = user -> datag[er + (ephi + 1) * N[0] + ez * N[0] * (N[1] + 1)] / (arrCoord[ez][ephi][er][icBphip[0]] * user->L0);
          countg = countg + 1;
        }

        if (countg > user -> numg) printf("countg = [%d] exceeds numg = [%d]\n", countg, user -> numg);

        /* tau(r, phi, z, t=0) of Xcopy initialized with psi values. */
        arrXcopy[ez][ephi][er][ivErmzm] = user -> datapsi[er + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErmzm[0]] * user->L0);
        countpsi = countpsi + 1;
        if (er == N[0] - 1) {
          arrXcopy[ez][ephi][er][ivErpzm] = user -> datapsi[er + 1 + ephi * (N[0] + 1) + ez * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErpzm[0]] * user->L0);
          countpsi = countpsi + 1;
        }
        if (ez == N[2] - 1) {
          arrXcopy[ez][ephi][er][ivErmzp] = user -> datapsi[er + ephi * (N[0] + 1) + (ez + 1) * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErmzp[0]] * user->L0);
          countpsi = countpsi + 1;
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrXcopy[ez][ephi][er][ivErpzp] = user -> datapsi[er + 1 + ephi * (N[0] + 1) + (ez + 1) * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErpzp[0]] * user->L0);
          countpsi = countpsi + 1;
        }
        if (countpsi > user -> numpsi) printf("countpsi = [%d] exceeds numpsi = [%d]\n", countpsi, user -> numpsi);

        /* n_i(r, phi, z, t=0) = ni_0 */
        arrX[ez][ephi][er][ivn] = 1.0;
      }
    }
  }

  /* Restore vectors */
  DMStagVecRestoreArray(da, xLocal, & arrX);
  DMStagVecRestoreArray(da, XcopyLocal , & arrXcopy);
  PetscFree(user->datag);
  PetscFree(user->datapsi);

  if (user -> itime == 0.0) {
    Vec curl;
    DMLocalToGlobal(da, xLocal, INSERT_VALUES, X);
    DMLocalToGlobal(da, XcopyLocal, INSERT_VALUES, Xcopy);
    DMRestoreLocalVector(da, & xLocal);
    DMRestoreLocalVector(da, & XcopyLocal);

    DMCreateGlobalVector(da, & curl);
    VecScale(curl,0.0);
    //Apply primary curl to Xcopy, and save in curl
    FormPrimaryCurl(ts, Xcopy, curl, user);
    //X := X - (1/L0)curl;
    VecAXPY(X,-1.0 / user->L0,curl);
    //Normalize wrt B_0
    VecGetSubVector( X, user -> isB, & curl);
    VecScale(curl, 1.0 / user->B0); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( X, user -> isB, & curl);
    //Destroy vectors
    VecDestroy(& Xcopy);
    VecDestroy(& curl);


    if(user->EnableReadICFromBinary){
      char filename[PETSC_MAX_PATH_LEN];
      PetscViewer viewerX;

      /* Read X in binary file */
      PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, 30, 3000.0);  //466, 148.7528808   113, 2514.1526823
      PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
      PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
      VecLoad(X, viewerX);
      /* Destroy the viewer */
      PetscViewerDestroy( & viewerX);
      PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
    }

  } else if(user->EnableReadICFromBinary){
    char filename[PETSC_MAX_PATH_LEN];
    PetscViewer viewerX;
    // THIS READS X data after relaxation for unknown resitivity

    /* Read X in binary file */
    PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, (int)(user -> oldstep), (double) user -> itime);
    PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
    PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
    VecLoad(X, viewerX);
    /* Destroy the viewer */
    PetscViewerDestroy( & viewerX);
    PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
  }

  if ( (user -> ictype == 9 || user -> ictype == 15) && user -> itime == 0.0 && user->EnableRelaxation) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;
    TSAdapt adapt;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);
    TSMonitorSet(dummyts, Monitor, user, NULL); /* Set optional user-defined monitoring routine */
    TSSetProblemType(dummyts, TS_NONLINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSGetAdapt(dummyts, & adapt);
    TSAdaptSetType(adapt, TSADAPTNONE);
    TSSetType(dummyts, TSARKIMEX); /* Additive Runge-Kutta IMEX method */
    TSARKIMEXSetFullyImplicit(dummyts, PETSC_TRUE);
    TSARKIMEXSetType(dummyts, TSARKIMEXL2);
    TSSetEquationType(dummyts,TS_EQ_IMPLICIT);

    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_newequilibrium_Vperp, user);
    TSSetRHSFunction(dummyts, NULL, FormRHSFunction_BImplicit, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    //TSSetTime(dummyts, 0.0);
    TSSetTime(dummyts, user->itime);
    // TSSetDuration(dummyts,30,3000.0);
    TSSetMaxTime(dummyts, 3000.0);
    TSSetMaxSteps(dummyts, 30);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 100.0);
    TSSetSolution(dummyts, X);



    SNESGetKSP(dummysnes, & dummyKSP);
    //TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);

    PCSetType(dummypc,PCBJACOBI);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    PetscBool is_fieldsplit;
    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;


        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_EP[1], stencil_noe_notEP[6];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EP", "BV"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is 4th dofs on vertices
          stencil_noe_EP[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_EP[0].c = 3;

          // Second split within notv is faces and the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_notEP[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_notEP[c].c = c;
          }
          stencil_noe_notEP[3].loc = DMSTAG_LEFT;
          stencil_noe_notEP[3].c = 0;
          stencil_noe_notEP[4].loc = DMSTAG_BACK;
          stencil_noe_notEP[4].c = 0;
          stencil_noe_notEP[5].loc = DMSTAG_DOWN;
          stencil_noe_notEP[5].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_noe,1,stencil_noe_EP,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,6,stencil_noe_notEP,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      PC            pc_noe_2;

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"B", "V"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,3,0,1,0,&dm_notv));

          // First split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          // Second split within notv is vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notv_notfaces[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notv_notfaces[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_notfaces,&is_notv[1]));


          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-6,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);

    TSSolve(dummyts, X);
    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    PetscPrintf(PETSC_COMM_WORLD, "Saving solution after relaxation with resitivity %le...", user->etaplasma);
    SaveIntermediateSolution(dummyts, steps, ftime, X, user);

    if(0){
      Vec residual;
      VecDuplicate(X,&residual);

      //Vec Xdot;
      //VecDuplicate(X,&Xdot);
      //VecZeroEntries(Xdot);
      //FormIFunction_Vperp_viscosity(ts, time, X, Xdot, residual, user);
      //VecDestroy( & Xdot);

      SNESGetFunction(dummysnes, & residual, NULL, NULL);
      DumpSolution_Cell(dummyts, (int)(900), residual, user);
      //VecDestroy( & residual);
    }


    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions for B and V: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    SaveIntermediateSolution(dummyts, steps, ftime, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
  }

  //  if(0){
  if ( (user -> ictype == 9 || user -> ictype == 15) && (user -> itime == 0.0) && 1) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);
    //TSMonitorSet(dummyts, Monitor, user, NULL); /* Set optional user-defined monitoring routine */
    TSSetProblemType(dummyts, TS_NONLINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSSetType(dummyts, TSBEULER);
    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_InitializeEP_halo, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    TSSetTime(dummyts, 0.0);
    TSSetMaxTime(dummyts, 1e-2);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 1e-2);
    TSSetSolution(dummyts, X);

    SNESGetKSP(dummysnes, & dummyKSP);
    //TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);

    PCSetType(dummypc,PCBJACOBI);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    PetscBool is_fieldsplit;
    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;


        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_EP[1], stencil_noe_notEP[6];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EP", "BV"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is 4th dofs on vertices
          stencil_noe_EP[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_EP[0].c = 3;

          // Second split within notv is faces and the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_notEP[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_notEP[c].c = c;
          }
          stencil_noe_notEP[3].loc = DMSTAG_LEFT;
          stencil_noe_notEP[3].c = 0;
          stencil_noe_notEP[4].loc = DMSTAG_BACK;
          stencil_noe_notEP[4].c = 0;
          stencil_noe_notEP[5].loc = DMSTAG_DOWN;
          stencil_noe_notEP[5].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_noe,1,stencil_noe_EP,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,6,stencil_noe_notEP,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      PC            pc_noe_2;

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"B", "V"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,3,0,1,0,&dm_notv));

          // First split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          // Second split within notv is vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notv_notfaces[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notv_notfaces[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_notfaces,&is_notv[1]));


          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-8,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);

    TSSolve(dummyts, X);


    if(0){
      Vec residual;
      VecDuplicate(X,&residual);

      //Vec Xdot;
      //VecDuplicate(X,&Xdot);
      //VecZeroEntries(Xdot);
      //FormIFunction_Vperp_viscosity(ts, time, X, Xdot, residual, user);
      //VecDestroy( & Xdot);

      SNESGetFunction(dummysnes, & residual, NULL, NULL);
      DumpSolution_Cell(dummyts, (int)(900), residual, user);
      //VecDestroy( & residual);
    }


    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions for EP and tau: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
  }

  if(0){
    Vec curl;
    VecGetSubVector( X, user -> isV, & curl);
    VecSet(curl, 1.0); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( X, user -> isV, & curl);
    //Destroy vectors
    VecDestroy(& curl);
  }

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  if (user -> debug) {
    /*This print is just for debugging*/
    PetscPrintf(PETSC_COMM_WORLD, "Initial solution vector\n");
    VecView(X, PETSC_VIEWER_STDOUT_WORLD);
  }

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return (0);
}

PetscErrorCode FormInitialSolution_psi_fromNphi2(TS ts, Vec X, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormInitialSolution_psi_fromNphi2",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da;
  PetscInt startr, startphi, startz, nr, nphi, nz;

  Vec xLocal, XcopyLocal, Xcopy;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];

  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];
  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  PetscScalar ** ** arrCoord, ** ** arrX, ** ** arrXcopy;
  PetscInt countg = 0, countpsi = 0;

  VecZeroEntries(X);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  for (d = 0; d < 3; ++d) {
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
  }

  VecDuplicate(X, & Xcopy);

  /* Compute function over the locally owned part of the grid */
  DMGetLocalVector(da, & XcopyLocal);
  DMGlobalToLocalBegin(da, Xcopy, INSERT_VALUES, XcopyLocal);
  DMGlobalToLocalEnd(da, Xcopy, INSERT_VALUES, XcopyLocal);
  DMStagVecGetArray(da, XcopyLocal , & arrXcopy);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);
  //Set X's magnetic field with G(psi)/r e_phi
  //Set Xcopy's tau field with psi/r e_phi
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        /* G(psi(r, z, t=0)) Loaded from ReadInitialData output */
        arrX[ez][ephi][er][ivBphim] = user -> datag[er + 0 * N[0] + ez * N[0] * (N[1] + 1)] / (arrCoord[ez][ephi][er][icBphim[0]] * user->L0);
        countg = countg + 1;

        if (ephi == N[1] - 1) {
          arrX[ez][ephi][er][ivBphip] = user -> datag[er + (0) * N[0] + ez * N[0] * (N[1] + 1)] / (arrCoord[ez][ephi][er][icBphip[0]] * user->L0);
          countg = countg + 1;
        }

        //if (countg > user -> numg) printf("countg = [%d] exceeds numg = [%d]\n", countg, user -> numg);

        /* tau(r, phi, z, t=0) of Xcopy initialized with psi values. */
        arrXcopy[ez][ephi][er][ivErmzm] = user -> datapsi[er + 0 * (N[0] + 1) + ez * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErmzm[0]] * user->L0);
        countpsi = countpsi + 1;
        if (er == N[0] - 1) {
          arrXcopy[ez][ephi][er][ivErpzm] = user -> datapsi[er + 1 + 0 * (N[0] + 1) + ez * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErpzm[0]] * user->L0);
          countpsi = countpsi + 1;
        }
        if (ez == N[2] - 1) {
          arrXcopy[ez][ephi][er][ivErmzp] = user -> datapsi[er + 0 * (N[0] + 1) + (ez + 1) * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErmzp[0]] * user->L0);
          countpsi = countpsi + 1;
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrXcopy[ez][ephi][er][ivErpzp] = user -> datapsi[er + 1 + 0 * (N[0] + 1) + (ez + 1) * N[1] * (N[0] + 1)] / (arrCoord[ez][ephi][er][icErpzp[0]] * user->L0);
          countpsi = countpsi + 1;
        }
        //if (countpsi > user -> numpsi) printf("countpsi = [%d] exceeds numpsi = [%d]\n", countpsi, user -> numpsi);

        /* n_i(r, phi, z, t=0) = ni_0 */
        arrX[ez][ephi][er][ivn] = 1.0;
      }
    }
  }

  /* Restore vectors */
  DMStagVecRestoreArray(da, xLocal, & arrX);
  DMStagVecRestoreArray(da, XcopyLocal , & arrXcopy);

  if (user -> itime == 0.0 && 1.0) {

    //PetscFree(user->datag);
    //PetscFree(user->datapsi);

    Vec curl;
    DMLocalToGlobal(da, xLocal, INSERT_VALUES, X);
    DMLocalToGlobal(da, XcopyLocal, INSERT_VALUES, Xcopy);
    DMRestoreLocalVector(da, & xLocal);
    DMRestoreLocalVector(da, & XcopyLocal);

    DMCreateGlobalVector(da, & curl);
    VecScale(curl,0.0);
    //Apply primary curl to Xcopy, and save in curl
    FormPrimaryCurl(ts, Xcopy, curl, user);
    //X := X - (1/L0)curl;
    VecAXPY(X,-1.0 / user->L0,curl);
    //Normalize wrt B_0
    VecGetSubVector( X, user -> isB, & curl);
    VecScale(curl, 1.0 / user->B0); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( X, user -> isB, & curl);
    //Destroy vectors
    VecDestroy(& Xcopy);
    VecDestroy(& curl);

    if(1){
      char filename[PETSC_MAX_PATH_LEN];
      PetscViewer viewerX;

      /* Read X in binary file */
      PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, 10, 1000.0);  //466, 148.7528808   113, 2514.1526823
      PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
      PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
      VecLoad(X, viewerX);
      /* Destroy the viewer */
      PetscViewerDestroy( & viewerX);
      PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
    }

  } else {
    char filename[PETSC_MAX_PATH_LEN];
    PetscViewer viewerX;

    /* Read X in binary file */
    PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, (int)(user -> oldstep), (double) user -> itime);
    PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
    PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
    VecLoad(X, viewerX);
    /* Destroy the viewer */
    PetscViewerDestroy( & viewerX);
    PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
  }

  if ( (user -> ictype == 9 || user -> ictype == 15) && user -> itime == 0.0 && 0.0) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;
    TSAdapt adapt;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);
    // TSMonitorSet(dummyts, Monitor, user, NULL); /* Set optional user-defined monitoring routine */
    TSSetProblemType(dummyts, TS_NONLINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSGetAdapt(dummyts, & adapt);
    TSAdaptSetType(adapt, TSADAPTNONE);
    TSSetType(dummyts, TSARKIMEX); /* Additive Runge-Kutta IMEX method */
    TSARKIMEXSetFullyImplicit(dummyts, PETSC_TRUE);
    TSARKIMEXSetType(dummyts, TSARKIMEXL2);
    TSSetEquationType(dummyts,TS_EQ_IMPLICIT);

    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_newequilibrium_Vperp, user);
    TSSetRHSFunction(dummyts, NULL, FormRHSFunction_BImplicit, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    //TSSetTime(dummyts, 0.0);
    TSSetTime(dummyts, user->itime);
    //TSSetMaxTime(dummyts, 2000.0);
    // TSSetDuration(dummyts,10,1000.0);
    TSSetMaxTime(dummyts, 1000.0);
    TSSetMaxSteps(dummyts, 10);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 100.0);
    TSSetSolution(dummyts, X);



    SNESGetKSP(dummysnes, & dummyKSP);
    //TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);

    PCSetType(dummypc,PCBJACOBI);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    PetscBool is_fieldsplit;
    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;


        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_EP[1], stencil_noe_notEP[6];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EP", "BV"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is 4th dofs on vertices
          stencil_noe_EP[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_EP[0].c = 3;

          // Second split within notv is faces and the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_notEP[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_notEP[c].c = c;
          }
          stencil_noe_notEP[3].loc = DMSTAG_LEFT;
          stencil_noe_notEP[3].c = 0;
          stencil_noe_notEP[4].loc = DMSTAG_BACK;
          stencil_noe_notEP[4].c = 0;
          stencil_noe_notEP[5].loc = DMSTAG_DOWN;
          stencil_noe_notEP[5].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_noe,1,stencil_noe_EP,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,6,stencil_noe_notEP,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      PC            pc_noe_2;

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"B", "V"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,3,0,1,0,&dm_notv));

          // First split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          // Second split within notv is vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notv_notfaces[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notv_notfaces[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_notfaces,&is_notv[1]));


          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-6,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);

    TSSolve(dummyts, X);

    if(0){
      Vec residual;
      VecDuplicate(X,&residual);

      //Vec Xdot;
      //VecDuplicate(X,&Xdot);
      //VecZeroEntries(Xdot);
      //FormIFunction_Vperp_viscosity(ts, time, X, Xdot, residual, user);
      //VecDestroy( & Xdot);

      SNESGetFunction(dummysnes, & residual, NULL, NULL);
      DumpSolution_Cell(dummyts, (int)(900), residual, user);
      //VecDestroy( & residual);
    }


    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions for B and V: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
  }

  if ( (user -> ictype == 9 || user -> ictype == 15) && user -> itime == 0.0 && 1.0) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);
    // TSMonitorSet(dummyts, Monitor, user, NULL); /* Set optional user-defined monitoring routine */
    TSSetProblemType(dummyts, TS_NONLINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSSetType(dummyts, TSBEULER);
    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_InitializeEP_halo, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    TSSetTime(dummyts, 0.0);
    TSSetMaxTime(dummyts, 1e-2);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 1e-2);
    TSSetSolution(dummyts, X);

    SNESGetKSP(dummysnes, & dummyKSP);
    //TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);

    PCSetType(dummypc,PCBJACOBI);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    PetscBool is_fieldsplit;
    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;


        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_EP[1], stencil_noe_notEP[6];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EP", "BV"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is 4th dofs on vertices
          stencil_noe_EP[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_EP[0].c = 3;

          // Second split within notv is faces and the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_notEP[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_notEP[c].c = c;
          }
          stencil_noe_notEP[3].loc = DMSTAG_LEFT;
          stencil_noe_notEP[3].c = 0;
          stencil_noe_notEP[4].loc = DMSTAG_BACK;
          stencil_noe_notEP[4].c = 0;
          stencil_noe_notEP[5].loc = DMSTAG_DOWN;
          stencil_noe_notEP[5].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_noe,1,stencil_noe_EP,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,6,stencil_noe_notEP,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      PC            pc_noe_2;

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"B", "V"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,3,0,1,0,&dm_notv));

          // First split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          // Second split within notv is vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notv_notfaces[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notv_notfaces[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_notfaces,&is_notv[1]));


          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-8,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);

    TSSolve(dummyts, X);


    if(0){
      Vec residual;
      VecDuplicate(X,&residual);

      //Vec Xdot;
      //VecDuplicate(X,&Xdot);
      //VecZeroEntries(Xdot);
      //FormIFunction_Vperp_viscosity(ts, time, X, Xdot, residual, user);
      //VecDestroy( & Xdot);

      SNESGetFunction(dummysnes, & residual, NULL, NULL);
      DumpSolution_Cell(dummyts, (int)(900), residual, user);
      //VecDestroy( & residual);
    }


    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions for EP and tau: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
  }

  if(0){
    Vec curl;
    VecGetSubVector( X, user -> isV, & curl);
    VecSet(curl, 1.0); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( X, user -> isV, & curl);
    //Destroy vectors
    VecDestroy(& curl);
  }

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  if (user -> debug) {
    /*This print is just for debugging*/
    PetscPrintf(PETSC_COMM_WORLD, "Initial solution vector\n");
    VecView(X, PETSC_VIEWER_STDOUT_WORLD);
  }

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return (0);
}

PetscErrorCode FormInitialpsi(TS ts, Vec X, void * ptr) {

  PetscLogEvent  USER_EVENT;
  PetscClassId   classid;
  PetscLogDouble user_event_flops;

  PetscClassIdRegister("class name",&classid);
  PetscLogEventRegister("FormInitialpsi",classid,&USER_EVENT);
  PetscLogEventBegin(USER_EVENT,0,0,0,0);

  User * user = (User * ) ptr;
  DM da;
  PetscInt startr, startphi, startz, nr, nphi, nz;

  Vec xLocal, XcopyLocal, Xcopy, psi, psiLocal;
  Vec coordLocal;
  PetscInt N[3], er, ephi, ez, d;

  PetscInt icBrp[3], icBphip[3], icBzp[3], icBrm[3], icBphim[3], icBzm[3];

  PetscInt icErmzm[3], icErmzp[3], icErpzm[3], icErpzp[3];
  PetscInt icEphimzm[3], icEphipzm[3], icEphimzp[3], icEphipzp[3];
  PetscInt icErmphim[3], icErpphim[3], icErmphip[3], icErpphip[3];

  PetscInt ivn;

  PetscInt ivBrp, ivBphip, ivBzp, ivBrm, ivBphim, ivBzm;

  PetscInt ivErmzm, ivErmzp, ivErpzm, ivErpzp;
  PetscInt ivEphimzm, ivEphipzm, ivEphimzp, ivEphipzp;
  PetscInt ivErmphim, ivErpphim, ivErmphip, ivErpphip;

  PetscInt ivVrmphimzm[4], ivVrmphimzp[4], ivVrmphipzm[4], ivVrmphipzp[4];
  PetscInt ivVrpphimzm[4], ivVrpphipzm[4], ivVrpphipzp[4], ivVrpphimzp[4];

  DM dmCoord;
  PetscScalar ** ** arrCoord, ** ** arrX, ** ** arrXcopy, ** ** arrpsi;
  PetscInt countg = 0, countpsi = 0;

  VecZeroEntries(X);
  TSGetDM(ts, & da);
  DMStagGetGlobalSizes(da, & N[0], & N[1], & N[2]);
  DMStagGetCorners(da, & startr, & startphi, & startz, & nr, & nphi, & nz, NULL, NULL, NULL);
  for (d = 0; d < 4; ++d) {
    /* Vertex locations */
    DMStagGetLocationSlot(da, BACK_DOWN_LEFT, d, & ivVrmphimzm[d]);
    DMStagGetLocationSlot(da, BACK_DOWN_RIGHT, d, & ivVrpphimzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_LEFT, d, & ivVrmphipzm[d]);
    DMStagGetLocationSlot(da, BACK_UP_RIGHT, d, & ivVrpphipzm[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_LEFT, d, & ivVrmphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_DOWN_RIGHT, d, & ivVrpphimzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_LEFT, d, & ivVrmphipzp[d]);
    DMStagGetLocationSlot(da, FRONT_UP_RIGHT, d, & ivVrpphipzp[d]);
  }
  /* Edge locations */
  DMStagGetLocationSlot(da, BACK_LEFT, 0, & ivErmzm);
  DMStagGetLocationSlot(da, BACK_DOWN, 0, & ivEphimzm);
  DMStagGetLocationSlot(da, BACK_RIGHT, 0, & ivErpzm);
  DMStagGetLocationSlot(da, BACK_UP, 0, & ivEphipzm);
  DMStagGetLocationSlot(da, DOWN_LEFT, 0, & ivErmphim);
  DMStagGetLocationSlot(da, DOWN_RIGHT, 0, & ivErpphim);
  DMStagGetLocationSlot(da, UP_LEFT, 0, & ivErmphip);
  DMStagGetLocationSlot(da, UP_RIGHT, 0, & ivErpphip);
  DMStagGetLocationSlot(da, FRONT_DOWN, 0, & ivEphimzp);
  DMStagGetLocationSlot(da, FRONT_LEFT, 0, & ivErmzp);
  DMStagGetLocationSlot(da, FRONT_RIGHT, 0, & ivErpzp);
  DMStagGetLocationSlot(da, FRONT_UP, 0, & ivEphipzp);
  /* Face locations */
  DMStagGetLocationSlot(da, LEFT, 0, & ivBrm);
  DMStagGetLocationSlot(da, DOWN, 0, & ivBphim);
  DMStagGetLocationSlot(da, BACK, 0, & ivBzm);
  DMStagGetLocationSlot(da, RIGHT, 0, & ivBrp);
  DMStagGetLocationSlot(da, UP, 0, & ivBphip);
  DMStagGetLocationSlot(da, FRONT, 0, & ivBzp);
  /* Cell locations */
  DMStagGetLocationSlot(da, ELEMENT, 0, & ivn);

  DMGetCoordinateDM(da, & dmCoord);
  DMGetCoordinatesLocal(da, & coordLocal);
  DMStagVecGetArrayRead(dmCoord, coordLocal, & arrCoord);
  for (d = 0; d < 3; ++d) {
    /* Face coordinates */
    DMStagGetLocationSlot(dmCoord, LEFT, d, & icBrm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN, d, & icBphim[d]);
    DMStagGetLocationSlot(dmCoord, BACK, d, & icBzm[d]);
    DMStagGetLocationSlot(dmCoord, RIGHT, d, & icBrp[d]);
    DMStagGetLocationSlot(dmCoord, UP, d, & icBphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT, d, & icBzp[d]);
    /* Edge coordinates */
    DMStagGetLocationSlot(dmCoord, BACK_LEFT, d, & icErmzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_DOWN, d, & icEphimzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_RIGHT, d, & icErpzm[d]);
    DMStagGetLocationSlot(dmCoord, BACK_UP, d, & icEphipzm[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_LEFT, d, & icErmphim[d]);
    DMStagGetLocationSlot(dmCoord, DOWN_RIGHT, d, & icErpphim[d]);
    DMStagGetLocationSlot(dmCoord, UP_LEFT, d, & icErmphip[d]);
    DMStagGetLocationSlot(dmCoord, UP_RIGHT, d, & icErpphip[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_DOWN, d, & icEphimzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_LEFT, d, & icErmzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_RIGHT, d, & icErpzp[d]);
    DMStagGetLocationSlot(dmCoord, FRONT_UP, d, & icEphipzp[d]);
  }


  if ( (user -> ictype == 9) && (user -> itime == 0.0) ) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);
    //TSMonitorSet(dummyts, Monitor, user, NULL); /* Set optional user-defined monitoring routine */
    TSSetProblemType(dummyts, TS_NONLINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSSetType(dummyts, TSBEULER);
    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_Initializepsi, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    TSSetTime(dummyts, 0.0);
    TSSetMaxTime(dummyts, 1e-2);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 1e-2);
    TSSetSolution(dummyts, X);

    SNESGetKSP(dummysnes, & dummyKSP);
    //TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);

    PCSetType(dummypc,PCBJACOBI);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    PetscBool is_fieldsplit;
    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;


        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_EP[1], stencil_noe_notEP[6];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EP", "BV"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is 4th dofs on vertices
          stencil_noe_EP[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_EP[0].c = 3;

          // Second split within notv is faces and the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_notEP[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_notEP[c].c = c;
          }
          stencil_noe_notEP[3].loc = DMSTAG_LEFT;
          stencil_noe_notEP[3].c = 0;
          stencil_noe_notEP[4].loc = DMSTAG_BACK;
          stencil_noe_notEP[4].c = 0;
          stencil_noe_notEP[5].loc = DMSTAG_DOWN;
          stencil_noe_notEP[5].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_noe,1,stencil_noe_EP,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,6,stencil_noe_notEP,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      PC            pc_noe_2;

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"B", "V"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,3,0,1,0,&dm_notv));

          // First split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          // Second split within notv is vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notv_notfaces[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notv_notfaces[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_notfaces,&is_notv[1]));


          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-8,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);

    TSSolve(dummyts, X);

    if(1){
      Vec residual;
      VecDuplicate(X,&residual);

      //Vec Xdot;
      //VecDuplicate(X,&Xdot);
      //VecZeroEntries(Xdot);
      //FormIFunction_Vperp_viscosity(ts, time, X, Xdot, residual, user);
      //VecDestroy( & Xdot);

      SNESGetFunction(dummysnes, & residual, NULL, NULL);
      DumpSolution_Cell(dummyts, (int)(900), residual, user);
      //VecDestroy( & residual);
    }

    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions for psi: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
    //exit (EXIT_FAILURE);
  }

  if(1){
    DumpSolution_Cell(ts, (int)(700), X, user);
    Vec residual;
    VecDuplicate(X,&residual);
    VecZeroEntries(residual);
    ApplyDeltastar2(ts, X, residual, user);
    DumpSolution_Cell(ts, (int)(800), residual, user);
    VecDestroy( & residual);
    //exit (EXIT_FAILURE);
  }


  VecDuplicate(X, & psi);
  VertexToEdgeReconstruction_scalar(ts, X, psi, user);

  if(0){
    DumpSolution_Cell(ts, (int)(720), psi, user);
    exit (EXIT_FAILURE);
  }

  VecZeroEntries(X);
  DMGetLocalVector(da, & psiLocal);
  DMGlobalToLocalBegin(da, psi, INSERT_VALUES, psiLocal);
  DMGlobalToLocalEnd(da, psi, INSERT_VALUES, psiLocal);
  DMStagVecGetArray(da, psiLocal, & arrpsi);


  VecDuplicate(X, & Xcopy);
  VecZeroEntries(Xcopy);
  /* Compute function over the locally owned part of the grid */
  DMGetLocalVector(da, & XcopyLocal);
  DMGlobalToLocalBegin(da, Xcopy, INSERT_VALUES, XcopyLocal);
  DMGlobalToLocalEnd(da, Xcopy, INSERT_VALUES, XcopyLocal);
  DMStagVecGetArray(da, XcopyLocal , & arrXcopy);

  DMGetLocalVector(da, & xLocal);
  DMGlobalToLocalBegin(da, X, INSERT_VALUES, xLocal);
  DMGlobalToLocalEnd(da, X, INSERT_VALUES, xLocal);
  DMStagVecGetArray(da, xLocal, & arrX);
  //Set X's magnetic field with G(psi)/r e_phi
  //Set Xcopy's tau field with psi/r e_phi
  for (ez = startz; ez < startz + nz; ++ez) {
    for (ephi = startphi; ephi < startphi + nphi; ++ephi) {
      for (er = startr; er < startr + nr; ++er) {
        /* G(psi(r, z, t=0)) Loaded from ReadInitialData output */
        arrX[ez][ephi][er][ivBphim] = -32.86 / arrCoord[ez][ephi][er][icBphim[0]] ;
        countg = countg + 1;

        if (ephi == N[1] - 1) {
          arrX[ez][ephi][er][ivBphip] = -32.86 / arrCoord[ez][ephi][er][icBphip[0]] ;
          countg = countg + 1;
        }

        /* tau(r, phi, z, t=0) of Xcopy initialized with psi values. */
        arrXcopy[ez][ephi][er][ivErmzm] = arrpsi[ez][ephi][er][ivErmzm] / arrCoord[ez][ephi][er][icErmzm[0]] ;
        countpsi = countpsi + 1;
        if (er == N[0] - 1) {
          arrXcopy[ez][ephi][er][ivErpzm] = arrpsi[ez][ephi][er][ivErpzm] / arrCoord[ez][ephi][er][icErpzm[0]];
          countpsi = countpsi + 1;
        }
        if (ez == N[2] - 1) {
          arrXcopy[ez][ephi][er][ivErmzp] = arrpsi[ez][ephi][er][ivErmzp] / arrCoord[ez][ephi][er][icErmzp[0]];
          countpsi = countpsi + 1;
        }
        if (er == N[0] - 1 && ez == N[2] - 1) {
          arrXcopy[ez][ephi][er][ivErpzp] = arrpsi[ez][ephi][er][ivErpzp] / arrCoord[ez][ephi][er][icErpzp[0]];
          countpsi = countpsi + 1;
        }

        /* n_i(r, phi, z, t=0) = ni_0 */
        arrX[ez][ephi][er][ivn] = 1.0;
      }
    }
  }

  /* Restore vectors */
  DMStagVecRestoreArray(da, psiLocal, & arrpsi);
  DMStagVecRestoreArray(da, xLocal, & arrX);
  DMStagVecRestoreArray(da, XcopyLocal , & arrXcopy);

  if (user -> itime == 0.0) {
    Vec curl;
    DMLocalToGlobal(da, xLocal, INSERT_VALUES, X);
    DMLocalToGlobal(da, XcopyLocal, INSERT_VALUES, Xcopy);
    DMRestoreLocalVector(da, & psiLocal);
    DMRestoreLocalVector(da, & xLocal);
    DMRestoreLocalVector(da, & XcopyLocal);

    DMCreateGlobalVector(da, & curl);
    VecScale(curl,0.0);
    //Apply primary curl to Xcopy, and save in curl
    FormPrimaryCurl(ts, Xcopy, curl, user);

    Vec tau;
    VecGetSubVector( curl, user -> istau, & tau);
    VecScale(tau, 0.0); // tau := 0
    VecRestoreSubVector( curl, user -> istau, & tau);
    if(0){
      DumpSolution_Cell(ts, (int)(730), X, user);
      DumpSolution_Cell(ts, (int)(740), curl, user);
      //exit (EXIT_FAILURE);
    }

    //X := X - curl;
    VecAXPY(X,-1.0,curl);
    //Normalize wrt B_0
    VecGetSubVector( X, user -> isB, & curl);
    VecScale(curl, 0.2); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( X, user -> isB, & curl);
    //Destroy vectors
    VecDestroy(& psi);
    VecDestroy(& Xcopy);
    VecDestroy(& curl);
  } else {
    char filename[PETSC_MAX_PATH_LEN];
    PetscViewer viewerX;

    /* Read X in binary file */
    PetscSNPrintf(filename, sizeof(filename), "%s/X_ic%.2d_grid%.2dx%.2dx%.2d_step%.3d_time%5.7f.dat", user->input_folder, user -> ictype, user -> Nr, user -> Nphi, user -> Nz, (int)(user -> oldstep), (double) user -> itime);
    PetscPrintf(PETSC_COMM_WORLD, "Reading X vector from file %s ...\n", filename);
    PetscViewerBinaryOpen(PETSC_COMM_WORLD, filename, FILE_MODE_READ, & viewerX);
    VecLoad(X, viewerX);
    /* Destroy the viewer */
    PetscViewerDestroy( & viewerX);
    PetscPrintf(PETSC_COMM_WORLD, "Reading from file %s is over.\n", filename);
  }

  if(0){
    DumpSolution_Cell(ts, (int)(750), X, user);
    exit (EXIT_FAILURE);
  }

  if ( (user -> ictype == 9 || user -> ictype == 15) ) {
    SNES dummysnes;
    TS dummyts;
    KSP dummyKSP;
    PC dummypc;
    Mat J;
    PetscInt steps;
    PetscReal ftime;
    TSConvergedReason reason;

    TSCreate(PETSC_COMM_WORLD, & dummyts);
    TSSetDM(dummyts, user->coorda);
    // TSMonitorSet(dummyts, Monitor, user, NULL); /* Set optional user-defined monitoring routine */
    TSSetProblemType(dummyts, TS_NONLINEAR);

    TSGetSNES(dummyts, & dummysnes);
    //SNESSetType(dummysnes, SNESKSPONLY);
    TSSetType(dummyts, TSBEULER);
    DMCreateMatrix(da, & J);
    /* Use coloring to compute finite difference J efficiently */
    SNESSetJacobian(dummysnes, J, J, SNESComputeJacobianDefaultColor, PETSC_NULLPTR);
    TSSetIFunction(dummyts, NULL, FormIFunction_InitializeEP, user);

    SNESSetUseMatrixFree(dummysnes,PETSC_TRUE,PETSC_FALSE);
    SNESSetOptionsPrefix(dummysnes, "dummySNES_");
    SNESSetFromOptions(dummysnes);

    TSSetTime(dummyts, 0.0);
    TSSetMaxTime(dummyts, 1e-2);
    TSSetExactFinalTime(dummyts, TS_EXACTFINALTIME_STEPOVER);
    TSSetTimeStep(dummyts, 1e-2);
    TSSetSolution(dummyts, X);

    SNESGetKSP(dummysnes, & dummyKSP);
    //TSGetKSP(dummyts, & dummyKSP);
    KSPGetPC(dummyKSP, & dummypc);

    PCSetType(dummypc,PCBJACOBI);
    KSPSetOptionsPrefix(dummyKSP, "dummyKSP_");

    /* Logic below modifies the PC directly, so this is the last chance to change the solver from the command line */
    PetscCall(KSPSetFromOptions(dummyKSP));

    PetscBool is_fieldsplit;
    {/* first level -> split ni from the rest : {ni}, {V Phi tau B}
        second level -> split tau from {V Phi B} : {ni}, {{tau},{V Phi B}}
        third level -> split V from {Phi B} : {ni}, {{tau},{{Phi B}, {V}}}
        fourth level -> split Phi from B : {ni}, {{tau},{{{Phi}, {B}}, {V}}}
        */
      IS            is[2];
      DMStagStencil stencil0[1], stencil1[10];
      PC            pc_notc, pc_noe;

      const char *name[2] = {"ni", "TEBV"};

      // First split is cells
      stencil0[0].loc = DMSTAG_ELEMENT;
      stencil0[0].c = 0;

      // Second split is the rest
      for (PetscInt c=0; c<4; ++c) {
        stencil1[c].loc = DMSTAG_BACK_DOWN_LEFT;
        stencil1[c].c = c;
      }
      stencil1[4].loc = DMSTAG_LEFT;
      stencil1[4].c = 0;
      stencil1[5].loc = DMSTAG_BACK;
      stencil1[5].c = 0;
      stencil1[6].loc = DMSTAG_DOWN;
      stencil1[6].c = 0;
      stencil1[7].loc = DMSTAG_BACK_DOWN;
      stencil1[7].c = 0;
      stencil1[8].loc = DMSTAG_BACK_LEFT;
      stencil1[8].c = 0;
      stencil1[9].loc = DMSTAG_DOWN_LEFT;
      stencil1[9].c = 0;

      PetscCall(DMStagCreateISFromStencils(da,1,stencil0,&is[0]));
      PetscCall(DMStagCreateISFromStencils(da,10,stencil1,&is[1]));

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(PCFieldSplitSetIS(dummypc,name[i],is[i]));
      }

      for (PetscInt i=0; i<2; ++i) {
        PetscCall(ISDestroy(&is[i]));
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split */
      {
        PCType pc_type;


        PetscCall(KSPGetPC(dummyKSP, &dummypc));
        PetscCall(PCGetType(dummypc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notc;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notc_edges[3], stencil_notc_notedges[7];
          IS            is_notc[2];
          const char    *name_notc[2] = {"tau","EBV"};

          PetscCall(PCSetUp(dummypc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(dummypc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_notc));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,1,1,0,&dm_notc));

          // First split within notc is edges
          stencil_notc_edges[0].loc = DMSTAG_BACK_DOWN;
          stencil_notc_edges[0].c = 0;
          stencil_notc_edges[1].loc = DMSTAG_BACK_LEFT;
          stencil_notc_edges[1].c = 0;
          stencil_notc_edges[2].loc = DMSTAG_DOWN_LEFT;
          stencil_notc_edges[2].c = 0;

          // Second split within notc is faces and vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notc_notedges[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notc_notedges[c].c = c;
          }
          stencil_notc_notedges[3].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_notc_notedges[3].c = 3;
          stencil_notc_notedges[4].loc = DMSTAG_LEFT;
          stencil_notc_notedges[4].c = 0;
          stencil_notc_notedges[5].loc = DMSTAG_BACK;
          stencil_notc_notedges[5].c = 0;
          stencil_notc_notedges[6].loc = DMSTAG_DOWN;
          stencil_notc_notedges[6].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_notc,3,stencil_notc_edges,&is_notc[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notc,7,stencil_notc_notedges,&is_notc[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_notc,name_notc[i],is_notc[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notc[i]));
          }
          PetscCall(DMDestroy(&dm_notc));
        }
      }

      /* If the fieldsplit PC wasn't overridden, further split the second split of the second level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_notc,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_noe;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_noe_EP[1], stencil_noe_notEP[6];
          IS            is_noe[2];
          const char    *name_noe[2] = {"EP", "BV"};

          PetscCall(PCSetUp(pc_notc)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_notc,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,4,0,1,0,&dm_noe));

          // First split within notv is 4th dofs on vertices
          stencil_noe_EP[0].loc = DMSTAG_BACK_DOWN_LEFT;
          stencil_noe_EP[0].c = 3;

          // Second split within notv is faces and the first 3 dofs on vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_noe_notEP[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_noe_notEP[c].c = c;
          }
          stencil_noe_notEP[3].loc = DMSTAG_LEFT;
          stencil_noe_notEP[3].c = 0;
          stencil_noe_notEP[4].loc = DMSTAG_BACK;
          stencil_noe_notEP[4].c = 0;
          stencil_noe_notEP[5].loc = DMSTAG_DOWN;
          stencil_noe_notEP[5].c = 0;

          PetscCall(DMStagCreateISFromStencils(dm_noe,1,stencil_noe_EP,&is_noe[0]));
          PetscCall(DMStagCreateISFromStencils(dm_noe,6,stencil_noe_notEP,&is_noe[1]));

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe,name_noe[i],is_noe[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_noe[i]));
          }
          PetscCall(DMDestroy(&dm_noe));
        }
      }

      PC            pc_noe_2;

      /* If the fieldsplit PC wasn't overridden, further split the first split of the third level */
      if (is_fieldsplit) {
        PCType pc_type;


        PetscCall(PCGetType(pc_noe,&pc_type));
        PetscCall(PetscStrcmp(pc_type,PCFIELDSPLIT,&is_fieldsplit));
        if (is_fieldsplit) {
          DM            dm_notv;
          KSP           *sub_ksp;

          PetscInt      n_splits;
          DMStagStencil stencil_notv_faces[3], stencil_notv_notfaces[3];
          IS            is_notv[2];
          const char    *name_notv[2] = {"B", "V"};

          PetscCall(PCSetUp(pc_noe)); // Set up the Fieldsplit PC
          PetscCall(PCFieldSplitGetSubKSP(pc_noe,&n_splits,&sub_ksp));
          PetscAssert(n_splits == 2,PetscObjectComm((PetscObject)da),PETSC_ERR_SUP,"Expected a Fieldsplit PC with two fields");
          PetscCall(KSPGetPC(sub_ksp[1],&pc_noe_2));
          PetscCall(PetscFree(sub_ksp));

          PetscCall(DMStagCreateCompatibleDMStag(da,3,0,1,0,&dm_notv));

          // First split within notv is faces
          stencil_notv_faces[0].loc = DMSTAG_LEFT;
          stencil_notv_faces[0].c = 0;
          stencil_notv_faces[1].loc = DMSTAG_BACK;
          stencil_notv_faces[1].c = 0;
          stencil_notv_faces[2].loc = DMSTAG_DOWN;
          stencil_notv_faces[2].c = 0;

          // Second split within notv is vertices
          for (PetscInt c=0; c<3; ++c) {
            stencil_notv_notfaces[c].loc = DMSTAG_BACK_DOWN_LEFT;
            stencil_notv_notfaces[c].c = c;
          }

          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_faces,&is_notv[0]));
          PetscCall(DMStagCreateISFromStencils(dm_notv,3,stencil_notv_notfaces,&is_notv[1]));


          for (PetscInt i=0; i<2; ++i) {
            PetscCall(PCFieldSplitSetIS(pc_noe_2,name_notv[i],is_notv[i]));
          }

          for (PetscInt i=0; i<2; ++i) {
            PetscCall(ISDestroy(&is_notv[i]));
          }
          PetscCall(DMDestroy(&dm_notv));
        }
      }
    }

    KSPSetTolerances(dummyKSP,1e-8,PETSC_DEFAULT,PETSC_DEFAULT,PETSC_DEFAULT);

    TSSolve(dummyts, X);


    if(0){
      Vec residual;
      VecDuplicate(X,&residual);

      //Vec Xdot;
      //VecDuplicate(X,&Xdot);
      //VecZeroEntries(Xdot);
      //FormIFunction_Vperp_viscosity(ts, time, X, Xdot, residual, user);
      //VecDestroy( & Xdot);

      SNESGetFunction(dummysnes, & residual, NULL, NULL);
      DumpSolution_Cell(dummyts, (int)(900), residual, user);
      //VecDestroy( & residual);
    }


    TSGetSolveTime(dummyts, & ftime);
    TSGetStepNumber(dummyts, & steps);
    TSGetConvergedReason(dummyts, & reason);
    PetscPrintf(PETSC_COMM_WORLD, "Setting Initial conditions for EP and tau: %s at time %g after %d steps\n", TSConvergedReasons[reason], (double) ftime, steps);
    //DumpSolution(ts, 50, X, user);
    MatDestroy( & J);
    TSDestroy( & dummyts);
  }

  if(0){
    DumpSolution_Cell(ts, (int)(770), X, user);
    //exit (EXIT_FAILURE);
  }

  if(0){
    Vec curl;
    VecGetSubVector( X, user -> isV, & curl);
    VecSet(curl, 1.0); // B := tilde{B} = (B_0^-1) B
    VecRestoreSubVector( X, user -> isV, & curl);
    //Destroy vectors
    VecDestroy(& curl);
  }

  DMStagVecRestoreArrayRead(dmCoord, coordLocal, & arrCoord);
  if (user -> debug) {
    /*This print is just for debugging*/
    PetscPrintf(PETSC_COMM_WORLD, "Initial solution vector\n");
    VecView(X, PETSC_VIEWER_STDOUT_WORLD);
  }

  user_event_flops = 0.0;
  PetscLogFlops(user_event_flops);
  PetscLogEventEnd(USER_EVENT,0,0,0,0);

  return (0);
}
